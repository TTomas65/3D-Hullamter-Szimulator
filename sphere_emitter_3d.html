<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <title>Hull√°mt√©r Szimul√°tor</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #fff;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 100;
            background: linear-gradient(135deg, rgba(15, 23, 42, 1) 0%, rgba(30, 41, 59, 1) 100%);
            backdrop-filter: blur(15px);
            border: none;
            border-right: 1px solid rgba(148, 163, 184, 0.2);
            padding: 24px;
            padding-bottom: 40px;
            border-radius: 0;
            color: #f8fafc;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            width: 380px;
            height: 100vh;
            overflow-y: auto;
            box-shadow: 4px 0 25px -5px rgba(0, 0, 0, 0.3);
            box-sizing: border-box;
        }
        
        /* Custom scrollbar for side panel */
        #controls::-webkit-scrollbar {
            width: 8px;
        }
        
        #controls::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.5);
        }
        
        #controls::-webkit-scrollbar-thumb {
            background: rgba(59, 130, 246, 0.5);
            border-radius: 4px;
        }
        
        #controls::-webkit-scrollbar-thumb:hover {
            background: rgba(59, 130, 246, 0.7);
        }
        
        /* Section header style for Extr√°k */
        .section-header {
            margin-bottom: 16px;
        }
        
        .section-header .panel-title {
            font-size: 16px;
        }
        
        #controls.collapsed {
            transform: translateX(-100%);
        }
        
        /* Side panel toggle button */
        #sidePanelToggle {
            position: fixed;
            top: 12px;
            left: 380px;
            z-index: 101;
            width: 28px;
            height: 40px;
            background: linear-gradient(135deg, rgba(15, 23, 42, 1) 0%, rgba(30, 41, 59, 1) 100%);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-left: none;
            border-radius: 0 8px 8px 0;
            color: #f8fafc;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1), background 0.3s ease;
            box-shadow: 4px 0 15px -5px rgba(0, 0, 0, 0.3);
            padding: 0;
            margin: 0;
        }
        
        #sidePanelToggle:hover {
            background: linear-gradient(135deg, rgba(30, 41, 59, 1) 0%, rgba(51, 65, 85, 1) 100%);
        }
        
        #sidePanelToggle.collapsed {
            left: 0;
        }
        
        #sidePanelToggle .arrow {
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #sidePanelToggle.collapsed .arrow {
            transform: rotate(180deg);
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 28px;
            position: relative;
        }
        
        /* Hide the old toggle button in controls panel */
        #controls #toggleControlsBtn {
            display: none;
        }

        .panel-title {
            font-weight: 600;
            font-size: 18px;
            color: #f1f5f9;
            letter-spacing: -0.025em;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        #controls .panel-title::before {
            content: '‚ö°';
            font-size: 20px;
            background: linear-gradient(45deg, #3b82f6, #8b5cf6);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        
        
        
        
        #toggleControlsBtn:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
            transform: translateY(-1px);
            box-shadow: 0 8px 25px 0 rgba(59, 130, 246, 0.4);
        }
        
        .control-group {
            margin-bottom: 24px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .control-group:hover {
            transform: translateX(2px);
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #cbd5e1;
            letter-spacing: -0.025em;
        }
        
        input[type="range"] {
            width: 240px;
            height: 6px;
            margin-bottom: 0;
            background: linear-gradient(to right, #1e293b 0%, #334155 100%);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            transition: all 0.3s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.6);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }
        
        .value-display {
            font-size: 13px;
            font-weight: 700;
            color: #ecebeb;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(29, 78, 216, 0.1) 100%);
            padding: 6px 12px;
            border-radius: 0px;
            border: 1px solid rgba(59, 130, 246, 0.2);
            font-family: 'Monaco', 'Menlo', monospace;
            min-width: 50px;
            text-align: center;
        }
        
        button {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            border: none;
            padding: 2px 2px;
            margin-right: 12px;
            margin-bottom: 8px;
            border-radius: 0px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 14px 0 rgba(59, 130, 246, 0.2);
        }
        
        button:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px 0 rgba(59, 130, 246, 0.3);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 4px 14px 0 rgba(59, 130, 246, 0.2);
        }
        
        select {
            background: #1f2937; /* S√∂t√©tsz√ºrke h√°tt√©r */
            color: #f8fafc;
            border: 1px solid rgba(100, 116, 139, 0.3);
            padding: 10px 16px;
            border-radius: 0px;
            font-size: 14px;
            font-weight: 500;
            width: 250px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select option {
            background: #1f2937;
            color: #f8fafc;
            padding: 10px;
        }
        
        select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
        
        select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        select:hover {
            border-color: rgba(148, 163, 184, 0.4);
        }
        
        #instructions {
            position: absolute;
            bottom: 24px;
            right: 24px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(15, 23, 42, 1) 0%, rgba(30, 41, 59, 1) 100%);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            padding: 24px;
            border-radius: 16px;
            color: #f8fafc;
            font-size: 14px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
            max-width: 400px;
            line-height: 1.6;
        }
        
        #instructionsCloseBtn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            transition: all 0.3s ease;
        }
        
        #instructionsCloseBtn:hover {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            transform: scale(1.05);
        }
        
        #version {
            position: absolute;
            top: 24px;
            right: 24px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        .version-container {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.9) 0%, rgba(79, 70, 229, 0.9) 100%);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            display: flex;
            align-items: baseline;
            gap: 6px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .version-number {
            font-size: 12px;
            opacity: 0.9;
            margin-left: 8px;
        }

        .github-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: rgba(17, 24, 39, 0.8);
            color: white;
            text-decoration: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .github-link:hover {
            background: rgba(31, 41, 55, 0.9);
            transform: translateY(-1px);
        }

        .github-link i {
            font-size: 14px;
        }
        
        .instructions-section {
            margin-bottom: 20px;
        }
        
        .instructions-title {
            margin: 0 0 12px 0;
            font-weight: 600;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-section {
            color: #60a5fa;
        }
        
        .function-section {
            color: #34d399;
        }
        
        .instruction-item {
            margin-bottom: 8px;
            padding-left: 4px;
            border-left: 2px solid rgba(148, 163, 184, 0.2);
            padding-left: 12px;
        }
        
        .instruction-item strong {
            color: #e2e8f0;
            font-weight: 600;
        }
        
        /* Anim√°ci√≥ a panel elemekhez */
        .control-group {
            opacity: 1;
            transform: translateY(0);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #controls.collapsed .control-group {
            opacity: 0;
            transform: translateY(-10px);
            transition-delay: 0s;
        }
        
        /* Hover effekt a cs√∫szk√°khoz */
        input[type="range"]:hover {
            background: linear-gradient(to right, #334155 0%, #475569 100%);
        }
        
        /* Elv√°laszt√≥ vonal */
        .divider {
            height: 1px;
            background: linear-gradient(to right, rgba(148, 163, 184, 0.1) 0%, rgba(148, 163, 184, 0.3) 50%, rgba(148, 163, 184, 0.1) 100%);
            margin: 16px 0;
            width: 100%;
        }
        
        /* Gombcsoportok */
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 16px;
        }
        
        .button-group button {
            flex: 1;
            min-width: 120px;
            margin-right: 0;
            white-space: nowrap;
            padding: 10px 12px;
            font-size: 13px;
        }
        
        /* Akt√≠v gombok st√≠lusa */
        button.active {
            background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
            box-shadow: 0 4px 14px 0 rgba(59, 130, 246, 0.5);
            transform: translateY(-1px);
        }
        
        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }


        /* ===== Panel‚Äëheader inline layout override (v8) ===== */
        .panel-header {
            display: flex !important;
            align-items: center;
            justify-content: space-between;
        }
        .panel-header .panel-title {
            flex: 1 1 auto;
            margin-right: 8px;
            white-space: nowrap;
        }
        .panel-header button {
            flex-shrink: 0;
        }


        /* ===== Scrollable instructions panel (v9) ===== */
        #instructions {
            position: fixed;
            bottom: 0;
            right: 0;
            width: 300px;
            height: 33.33vh; /* A k√©perny≈ë als√≥ 1/3-a */
            overflow-y: auto;
            backdrop-filter: blur(12px);
            background: rgba(15,23,42,0.95);
            border-left: 1px solid rgba(148,163,184,0.25);
            border-top: 1px solid rgba(148,163,184,0.25);
            border-radius: 12px 0 0 0;
            padding: 20px 24px 24px 24px;
            color: #f8fafc;
            font-size: 14px;
            line-height: 1.4;
            z-index: 120;
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #instructions.collapsed {
            right: -350px; /* Teljesen elt≈±nik a k√©perny≈ër≈ël */
        }
        
        /* Right instructions panel toggle button */
        #instructionsPanelToggle {
            position: fixed;
            top: calc(100vh - 33.33vh - 40px + 12px); /* A panel tetej√©n√©l, kicsit lejjebb */
            right: 348px; /* 300px panel + 45px kijjebb */
            z-index: 121;
            width: 28px;
            height: 40px;
            background: linear-gradient(135deg, rgba(15, 23, 42, 1) 0%, rgba(30, 41, 59, 1) 100%);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-right: none;
            border-radius: 8px 0 0 8px;
            color: #f8fafc;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1), background 0.3s ease;
            box-shadow: -4px 0 15px -5px rgba(0, 0, 0, 0.3);
            padding: 0;
            margin: 0;
        }
        
        #instructionsPanelToggle:hover {
            background: linear-gradient(135deg, rgba(30, 41, 59, 1) 0%, rgba(51, 65, 85, 1) 100%);
        }
        
        #instructionsPanelToggle.collapsed {
            right: 0px; /* 45px + 3px igaz√≠t√°s */
        }
        
        #instructionsPanelToggle .arrow {
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #instructionsPanelToggle.collapsed .arrow {
            transform: rotate(180deg);
        }
        
        #instructionsCloseBtn {
            display: none; /* Hide the old close button */
        }
        .instructions-section {
            margin-bottom: 16px;
        }
        .instructions-title {
            margin: 0 0 6px 0;
            font-weight: 600;
            font-size: 15px;
        }
        .instruction-item {
            margin-left: 8px;
            margin-bottom: 4px;
        }

        /* 3x3 Grid Selection Panel */
        #grid3x3Panel {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.95) 100%);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 16px;
            padding: 24px 32px;
            color: #f8fafc;
            font-size: 14px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            display: none;
            min-width: 520px;
        }
        
        #grid3x3Panel h3 {
            margin: 0 0 16px 0;
            font-size: 18px;
            font-weight: 600;
            text-align: center;
            color: #60a5fa;
        }
        
        #grid3x3Panel .instructions-text {
            margin-bottom: 20px;
            line-height: 1.6;
            color: #cbd5e1;
        }
        
        #grid3x3Panel .instructions-text strong {
            color: #fbbf24;
        }
        
        #grid3x3StartBtn {
            display: block;
            width: 100%;
            padding: 12px 24px;
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        #grid3x3StartBtn:hover {
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
            transform: scale(1.02);
        }
        
        #grid3x3StartBtn:disabled {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            cursor: not-allowed;
            transform: none;
        }
        
        .selected-count {
            text-align: center;
            margin-bottom: 16px;
            font-size: 16px;
            color: #fbbf24;
        }

</style>
</head>
<body>
    <!-- 3x3 Grid Selection Panel -->
    <div id="grid3x3Panel">
        <h3>üéØ 3x3-as T√©rr√°cs Kiv√°laszt√°s</h3>
        <div class="instructions-text">
            <strong>Utas√≠t√°sok:</strong><br>
            1. A 3D t√©rben megjelent egy 3√ó3√ó3-as kockah√°l√≥ 27 ponttal.<br>
            2. <strong>Kattints a s√∂t√©tsz√ºrke g√∂mb√∂kre</strong> a kiv√°laszt√°shoz - s√°rg√°ra v√°ltanak.<br>
            3. √öjabb kattint√°ssal visszavonhatod a kiv√°laszt√°st.<br>
            4. V√°laszd ki azokat a pontokat, ahov√° forr√°spontokat szeretn√©l helyezni.<br>
            5. Ha k√©sz, nyomd meg az <strong>Ind√≠t√°s</strong> gombot!
        </div>
        <div class="selected-count">Kiv√°lasztott pontok: <span id="selectedPointCount">0</span> / 27</div>
        <button id="grid3x3StartBtn" disabled>Ind√≠t√°s (v√°lassz legal√°bb 1 pontot)</button>
    </div>

    <div id="container">
        <div id="version">
            <div id="velocity-container" class="version-container">
                <span class="version-title">Forr√°spont Sebess√©ge</span>
                <span id="velocity-value" class="version-number">0.000</span>
            </div>
            <div class="version-container">
                <span class="version-title">Hull√°mt√©r Szimul√°tor</span>
                <span class="version-number">v1.40</span>
            </div>
            <a href="https://github.com/TTomas65/3D-Hullamter-Szimulator" target="_blank" class="github-link">
                Forr√°sk√≥d: <i class="fab fa-github"></i> GitHub
            </a>
        </div>
        
        
        <style>
            /* Screen recording button styles */
            #recordScreenBtn.recording {
                background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
                animation: pulse 1.5s infinite;
            }
            
            @keyframes pulse {
                0% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.7); }
                70% { box-shadow: 0 0 0 10px rgba(220, 38, 38, 0); }
                100% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0); }
            }
            
            /* Checkbox styles */
            .checkbox-container {
                display: flex;
                align-items: center;
                cursor: pointer;
                margin: 8px 0;
            }
            
            .checkbox-container input[type="checkbox"] {
                margin-right: 8px;
                appearance: none;
                -webkit-appearance: none;
                width: 18px;
                height: 18px;
                border: 1px solid rgba(148, 163, 184, 0.5);
                border-radius: 4px;
                background: rgba(30, 41, 59, 0.5);
                cursor: pointer;
                position: relative;
                outline: none;
            }
            
            .checkbox-container input[type="checkbox"]:checked {
                background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
                border-color: #3b82f6;
            }
            
            .checkbox-container input[type="checkbox"]:checked::after {
                content: "‚úì";
                position: absolute;
                color: white;
                font-size: 14px;
                top: -1px;
                left: 3px;
            }
            
            .checkbox-label {
                font-size: 14px;
                color: #f8fafc;
            }
        </style>


<div id="controls">
            <div class="panel-header">
                <div class="panel-title">Ir√°ny√≠t√≥ Panel</div>
                <button id="toggleControlsBtn" title="Panel √∂sszez√°r√°sa/kinyit√°sa"></button>
            </div>
            <div class="divider"></div>
            <div class="control-group">
                <label for="intensity">Ki√°rad√°si intenzit√°s</label>
                <input type="range" id="intensity" min="0" max="2" step="0.1" value="0.1">
                <div class="value-display" id="intensityValue">0.1</div>
            </div>
            
            <div class="control-group">
                <label for="opacity">√Åtl√°tsz√≥s√°g</label>
                <input type="range" id="opacity" min="0" max="1" step="0.05" value="0.5">
                <div class="value-display" id="opacityValue">0.50</div>
            </div>
            
            <div class="control-group">
                <label for="sourceSpeedX">Forr√°spont sebess√©ge X-tengely</label>
                <input type="range" id="sourceSpeedX" min="0" max="6" step="0.01" value="1.75">
                <div class="value-display" id="sourceSpeedXValue">1.75</div>
            </div>

            <div class="control-group">
                <label for="sourceSpeedY">Forr√°spont sebess√©ge Y-tengely</label>
                <input type="range" id="sourceSpeedY" min="0" max="6" step="0.01" value="0">
                <div class="value-display" id="sourceSpeedYValue">0.00</div>
            </div>

            <div class="control-group" id="circleRadiusControlGroup" style="display: none;">
                <label for="circleRadiusSlider">K√∂rmozg√°s sugara</label>
                <input type="range" id="circleRadiusSlider" min="0" max="5" step="0.1" value="4">
                <div class="value-display" id="circleRadiusValue">4.0</div>
            </div>
            <div class="divider"></div>
            <div class="control-group">
                <label for="movementType">Mozg√°st√≠pusok</label>
                <select id="movementType">
                    <option value="water">V√≠zelem</option>
                    <option value="grid3x3">3x3-as t√©rr√°cs elrendez√©s</option>
                    <option value="fire">T≈±zelem</option>
                    <option value="circular">K√∂rmozg√°s</option>
                    <option value="spiral">Spir√°lis mozg√°s</option>
                    <option value="dual">K√©t forr√°spont ki√°rad√°sa</option>
                </select>
            </div>
            
            <div class="control-group button-group">
                <button id="pauseBtn">Sz√ºnet</button>
                <button id="resetBtn">√öjrakezd</button>
                <button id="reloadBtn">√öjrat√∂lt√©s</button>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-group button-group">
                <button id="cameraResetBtn">Kamera Reset</button>
                <button id="topViewBtn">Fel√ºln√©zet</button>
                <button id="bottomViewBtn">Aluln√©zet</button>
            </div>
            
            <div class="control-group button-group">
                <button id="rightViewBtn">Oldaln√©zet jobb</button>
                <button id="leftViewBtn">Oldaln√©zet bal</button>
                <button id="rotateViewBtn">Forg√°s</button>
            </div>
            
            <div class="control-group button-group">
                <button id="followSourceBtn1">Forr√°spont k√∂vet√©se I.</button>
                <button id="followSourceBtn2">Forr√°spont k√∂vet√©se II.</button>
            </div>
            
            <!-- EXTR√ÅK szekci√≥ -->
            <div class="divider" style="margin: 24px 0;"></div>
            <div class="section-header">
                <div class="panel-title">‚ú® Extr√°k</div>
            </div>
            <div class="divider"></div>
            
            <div class="control-group button-group">
                <button id="clipXBtn">Metszet&nbsp;X</button>
                <button id="clipYBtn">Metszet&nbsp;Y</button>
            </div>

            <!-- Clipping plane sliders -->
            <div id="clipXSliderGroup" class="control-group" style="display:none;">
                <label for="clipXSlider">Metszet poz√≠ci√≥ X:</label>
                <input type="range" id="clipXSlider" min="-5" max="5" step="0.1" value="0">
                <div class="value-display" id="clipXSliderValue">0.0</div>
            </div>
            <div id="clipYSliderGroup" class="control-group" style="display:none;">
                <label for="clipYSlider">Metszet poz√≠ci√≥ Y:</label>
                <input type="range" id="clipYSlider" min="-5" max="5" step="0.1" value="0">
                <div class="value-display" id="clipYSliderValue">0.0</div>
            </div>
            
            <div class="divider"></div>
            <div class="control-group button-group">
                <button id="saveScreenshotBtn">K√©perny≈ëment√©s</button>
                <button id="recordScreenBtn">K√©perny≈ëvide√≥</button>
            </div>
            
            <div class="divider"></div>
            <div class="control-group">
                <label class="checkbox-container">
                    <input type="checkbox" id="showTimelineCheck">
                    <span class="checkbox-label">Id≈ësz√°l megjelen√≠t√©se</span>
                </label>
            </div>
        </div>
        
        <!-- Side panel toggle button -->
        <button id="sidePanelToggle" title="Panel ki/be g√∂rget√©se">
            <span class="arrow">‚óÄ</span>
        </button>
        
        <div id="instructions">
            <button id="instructionsCloseBtn">√ó</button>
            <div class="instructions-section">
                <h4 class="instructions-title">Inform√°ci√≥s Panel:</h4>
            </div>
            <div class="instructions-section">
                <h4 class="instructions-title">üñ±Ô∏è Eg√©r</h4>
                <div class="instruction-item"><strong>Bal eg√©rgomb:</strong> Ki√°rad√°si pont mozgat√°sa</div>
                <div class="instruction-item"><strong>Jobb eg√©rgomb:</strong> Kamera forgat√°sa (orbit)</div>
                <div class="instruction-item"><strong>Eg√©rg√∂rg≈ë:</strong> Nagy√≠t√°s / kicsiny√≠t√©s</div>
            </div>
            <div class="instructions-section">
                <h4 class="instructions-title">‚å®Ô∏è Billenty≈±k</h4>
                <div class="instruction-item"><strong>W / S:</strong> El≈ëre / H√°tra</div>
                <div class="instruction-item"><strong>A / D vagy ‚óÄ / ‚ñ∂:</strong> Balra / Jobbra</div>
                <div class="instruction-item"><strong>‚ñ≤ / ‚ñº:</strong> Felfel√© / Lefel√©</div>
                <div class="instruction-item"><strong>X:</strong> Forgat√°s X tengely k√∂r√ºl</div>
                <div class="instruction-item"><strong>Y:</strong> Forgat√°s Y tengely k√∂r√ºl</div>
                <div class="instruction-item"><strong>P:</strong> Sz√ºnet / Folytat√°s</div>
                <div class="instruction-item"><strong>O:</strong> Sebess√©g szab√°lyoz√°s (1x ‚Üí 1/2x ‚Üí 1/4x ‚Üí 1/8x ‚Üí 1x)</div>
                <div class="instruction-item"><strong>≈ë / √∫:</strong> Kamera forgat√°sa balra / jobbra</div>
                <div class="instruction-item"><strong>√° / ≈±:</strong> Kamera forgat√°sa fel / le</div>
            </div>
            <div class="instructions-section">
                <h4 class="instructions-title">üìê Metsz√©si vez√©rl√©s</h4>
                <div class="instruction-item"><strong>Metszet&nbsp;X gomb:</strong> Y‚Äëir√°ny√∫ metsz≈ës√≠k ki-/bekapcsol√°sa</div>
                <div class="instruction-item"><strong>Metszet&nbsp;Y gomb:</strong> X‚Äëir√°ny√∫ metsz≈ës√≠k ki-/bekapcsol√°sa</div>
                <div class="instruction-item"><strong>Metszet poz√≠ci√≥ cs√∫szk√°k:</strong> A s√≠k eltol√°sa ¬± ir√°nyban</div>
            </div>
            <div class="instructions-section">
                <h4 class="instructions-title">‚öôÔ∏è Egy√©b funkci√≥k</h4>
                <div class="instruction-item"><strong>Intenzit√°s:</strong> Ki√°rad√°si sebess√©g</div>
                <div class="instruction-item"><strong>√Åtl√°tsz√≥s√°g:</strong> G√∂mb megjelen√≠t√©s m√≥dja</div>
                <div class="instruction-item"><strong>Mozg√°st√≠pus:</strong> Forr√°spont anim√°ci√≥ m√≥dja</div>
                <div class="instruction-item"><strong>Sz√ºnet / √öjraind√≠t√°s gomb:</strong> Anim√°ci√≥ meg√°ll√≠t√°sa / folytat√°sa</div>
                <div class="instruction-item"><strong>Kamera reset:</strong> Kamera vissza alaphelyzetbe</div>
                <div class="instruction-item"><strong>K√©perny≈ëment√©s:</strong> Az aktu√°lis n√©zet (csak a tartalom) ment√©se JPG form√°tumban panelek n√©lk√ºl.</div>
                <div class="instruction-item"><strong>K√©perny≈ëvide√≥ r√∂gz√≠t√©se:</strong> Az aktu√°lis n√©zet vide√≥felv√©tele WebM form√°tumban.</div>
                <div class="instruction-item"><strong>Id≈ësz√°l megjelen√≠t√©se:</strong> A forr√°spont √°ltal kibocs√°tott g√∂mb√∂k k√∂z√©ppontjainak megjel√∂l√©se √©s √∂sszek√∂t√©se s√°rga sz√≠nnel.</div>
            </div>
        </div>
        
        <!-- Instructions panel toggle button -->
        <button id="instructionsPanelToggle" title="Inform√°ci√≥s panel ki/be g√∂rget√©se">
            <span class="arrow">‚ñ∂</span>
        </button>
        
    </div>
            
            <div class="instructions-section">
                <h4 class="instructions-title function-section">‚öôÔ∏è Funkci√≥k</h4>
                <div class="instruction-item"><strong>Intenzit√°s:</strong> Ki√°rad√°si sebess√©g szab√°lyoz√°sa</div>
                <div class="instruction-item"><strong>√Åtl√°tsz√≥s√°g:</strong> G√∂mb√∂k megjelen√≠t√©se (1=dr√≥tv√°z, 0=szil√°rd)</div>
                <div class="instruction-item"><strong>Forr√°spont sebess√©g:</strong> Mozg√°s sebess√©ge X/Y tengely</div>
                <div class="instruction-item"><strong>Mozg√°st√≠pusok:</strong> K√ºl√∂nb√∂z≈ë anim√°ci√≥s m√≥dok</div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script>
/* ====== Screenshot button ====== */
window.addEventListener('DOMContentLoaded', () => {
    const saveScreenshotBtn = document.getElementById('saveScreenshotBtn');
    if (saveScreenshotBtn && typeof renderer !== 'undefined') {
        saveScreenshotBtn.addEventListener('click', () => {
            renderer.render(scene, camera); // ensure latest frame
            const dataURL = renderer.domElement.toDataURL('image/jpeg');
            const now = new Date();
            const fileName = `kepernyomentes_${now.toISOString().slice(0,19).replace(/[:T]/g,'-')}.jpg`;
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = fileName;
            link.click();
        });
    }
});

</script>
    <script>
/* ========= WaveEmitter class ========= */
class WaveEmitter {
    constructor(mesh) {
        this.mesh = mesh;           // source mesh (red point)
        this.spheres = [];
        // A lastEmissionTime a korrig√°lt id≈ët haszn√°lja (performance.now() - totalPausedTime)
        // A konstruktorban a totalPausedTime m√©g 0, √≠gy ez rendben van
        this.lastEmissionTime = performance.now() - (typeof totalPausedTime !== 'undefined' ? totalPausedTime : 0);
        this.physics_velocity = new THREE.Vector3(0, 0, 0); // Forr√°spont fizikai sebess√©ge √ºtk√∂z√©s miatt
    }

    get position() { return this.mesh.position; }

    spawnSphere() {
        // create a new sphere at current position
        const geometry = new THREE.SphereGeometry(0.1, 32, 24);
        const baseMaterial = new THREE.MeshPhongMaterial({
            color: 0x6666ff,
            transparent: sphereOpacity > 0,
            opacity: 1 - sphereOpacity,
            shininess: 80,
            specular: 0x444444,
            side: THREE.DoubleSide
        });
        const wireMaterial = new THREE.MeshBasicMaterial({
            color: 0x404040,
            wireframe: true,
            transparent: false,
            opacity: 1.0,
            depthTest: true
        });
        const g = new THREE.Group();
        const solid = new THREE.Mesh(geometry, baseMaterial);
        const wire = new THREE.Mesh(geometry, wireMaterial);
        g.add(solid);
        g.add(wire);
        // A g√∂mb poz√≠ci√≥j√°nak be√°ll√≠t√°sa a forr√°spont aktu√°lis poz√≠ci√≥j√°ra
        const currentPosition = this.mesh.position.clone();
        g.position.copy(currentPosition);
        g.userData = {
            centerPosition: currentPosition,
            scale: 0.1,
            growthRate: 0.02,
            life: 0,
            baseMaterial,
            wireframeMaterial: wireMaterial,
            baseMesh: solid,
            wireframeMesh: wire,
            emitter: this,                   // Referencia a kibocs√°t√≥ forr√°spontra
            hasLeftSource: false,            // Jelzi, hogy a g√∂mb egyszer m√°r teljesen elhagyta-e a forr√°spontot
            canPushSource: false,            // Jelzi, hogy a g√∂mb k√©pes-e hatni a forr√°spontra
            hasPenetrated: false             // Jelzi, hogy a forr√°spont √°thatol√°son esett √°t ezen a g√∂mb fel√ºlet√©n
        };
        scene.add(g);
        spheres.push(g);
        this.spheres.push(g);
        
        // Mindig hozz√°adjuk a pontot az id≈ësz√°lhoz, f√ºggetlen√ºl att√≥l, hogy a megjelen√≠t√©s be van-e kapcsolva
        // T√°roljuk a pontot
        // ------ Id≈ësz√°l kezel√©se t√∂bb forr√°sponthoz igaz√≠tva ------
        if (!this.timeline) {
            // Minden emitter saj√°t id≈ësz√°l‚Äëlist√°kat kap
            this.timeline = { points: [], markers: [], lines: [] };
        }
        // √öj pont felv√©tele az adott emitter id≈ësz√°l√°ra
        this.timeline.points.push(currentPosition.clone());
        
        // S√°rga jel√∂l≈ë l√©trehoz√°sa
        const markerGeometry = new THREE.SphereGeometry(0.009, 16, 16);
        const markerMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, shininess: 80, specular: 0x444444 });
        const marker = new THREE.Mesh(markerGeometry, markerMaterial);
        marker.position.copy(currentPosition);
        if (showTimeline) scene.add(marker);
        timelineMarkers.push(marker);
        this.timeline.markers.push(marker);
        
        // Az el≈ëz≈ë saj√°t ponttal √∂sszek√∂t≈ë vonal elk√©sz√≠t√©se
        if (this.timeline.points.length > 1) {
            const pts = this.timeline.points;
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                pts[pts.length - 2], pts[pts.length - 1]
            ]);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            if (showTimeline) scene.add(line);
            timelineLines.push(line);
            this.timeline.lines.push(line);
        }
    }

    update(now) {
        const interval = 200 / (emissionIntensity * speedMultiplier); // ms - lassabb sebess√©g = hosszabb intervallum
        if (now - this.lastEmissionTime >= interval) {
            this.spawnSphere();
            this.lastEmissionTime = now;
        }
    }

    resync() { 
        // √öjraszinkroniz√°l√°s a korrig√°lt id≈ëh√∂z
        this.lastEmissionTime = performance.now() - totalPausedTime; 
    }

    // √útk√∂z√©sdetekt√°l√°s √©s fizika friss√≠t√©se
    // A fizikai modell a forr√°spont √©s a t√°gul√≥ g√∂mbfel√ºlet RELAT√çV sebess√©g√©t veszi figyelembe
    // A g√∂mb t√°gul√°si sebess√©ge mindig 1 fizikai egys√©g (PHYSICS_UNIT_SPEED)
    updateCollisionPhysics() {
        const sourceRadius = 0.007; // A forr√°spont sugara
        const sphereExpansionSpeed = PHYSICS_UNIT_SPEED; // A g√∂mb t√°gul√°si sebess√©ge = 1 fizikai egys√©g

        // √útk√∂z√©s ellen≈ërz√©se az √∂sszes g√∂mbbel
        for (let sphere of spheres) {
            const userData = sphere.userData;
            const sphereCenter = userData.centerPosition;
            const sphereRadius = userData.scale * 0.1; // 0.1 az alapm√©ret
            const sourcePosition = this.mesh.position;
            const distance = sphereCenter.distanceTo(sourcePosition);

            // √útk√∂z√©si felt√©tel - a forr√°spont a g√∂mb fel√ºlet√©n vagy bel√ºl van
            if (distance <= sphereRadius + sourceRadius) {
                const isOurEmitterSphere = userData.emitter === this;
                const canInfluenceSource = !isOurEmitterSphere || userData.canPushSource;

                if (sphereRadius >= 2 * sourceRadius && canInfluenceSource) {
                    // Ir√°nyvektor a g√∂mb k√∂z√©ppontj√°b√≥l a forr√°spont fel√© (radi√°lis ir√°ny, kifel√©)
                    const radialOutward = new THREE.Vector3()
                        .subVectors(sourcePosition, sphereCenter)
                        .normalize();
                    
                    if (radialOutward.lengthSq() === 0) continue;

                    // A forr√°spont radi√°lis sebess√©ge (pozit√≠v = kifel√© mozog, negat√≠v = befel√© mozog)
                    const sourceRadialSpeed = this.physics_velocity.dot(radialOutward);
                    
                    // A g√∂mbfel√ºlet radi√°lis sebess√©ge (mindig kifel√© t√°gul, teh√°t pozit√≠v)
                    const surfaceRadialSpeed = sphereExpansionSpeed;
                    
                    // RELAT√çV sebess√©g: forr√°spont sebess√©ge a g√∂mbfel√ºlethez k√©pest
                    // Ha pozit√≠v: a forr√°spont gyorsabban mozog kifel√© mint a fel√ºlet (el≈ëzi/elhagyja)
                    // Ha negat√≠v: a fel√ºlet utol√©ri a forr√°spontot (befel√© mozog vagy lassabban kifel√©)
                    const relativeRadialSpeed = sourceRadialSpeed - surfaceRadialSpeed;
                    
                    // Normaliz√°lt relat√≠v sebess√©g (fizikai egys√©gekben)
                    const normalizedRelativeSpeed = relativeRadialSpeed / PHYSICS_UNIT_SPEED;

                    // DEBUG log
                    console.log(`Collision: sourceRadial=${(sourceRadialSpeed/PHYSICS_UNIT_SPEED).toFixed(2)}, surfaceRadial=${(surfaceRadialSpeed/PHYSICS_UNIT_SPEED).toFixed(2)}, relative=${normalizedRelativeSpeed.toFixed(2)}`);

                    // ESET 1: A forr√°spont KIFEL√â mozog gyorsabban mint a fel√ºlet t√°gul
                    // (el≈ëzi vagy elhagyja a fel√ºletet bel√ºlr≈ël kifel√©)
                    // Ilyenkor a fel√ºlet NEM HAT a forr√°spontra
                    if (relativeRadialSpeed > 0) {
                        // Bel√ºlr≈ël kifel√© el≈ëz√©s/elhagy√°s - nincs hat√°s
                        userData.hasPenetrated = true;
                        userData.hasLeftSource = true;
                        userData.canPushSource = true;
                        console.log('OUTWARD: Source moving faster than surface - no effect');
                        continue; // Nincs tov√°bbi feldolgoz√°s erre a g√∂mbra
                    }
                    
                    // ESET 2: A fel√ºlet UTOL√âRI a forr√°spontot (relat√≠v sebess√©g negat√≠v)
                    // A forr√°spont vagy befel√© mozog, vagy lassabban kifel√© mint a fel√ºlet
                    
                    // Az "√ºtk√∂z√©si" sebess√©g nagys√°ga (abszol√∫t √©rt√©k)
                    const collisionSpeed = Math.abs(normalizedRelativeSpeed);
                    
                    if (collisionSpeed <= 1.0) {
                        // ALACSONY relat√≠v sebess√©g (‚â§1): TASZ√çT√ÅS
                        // A fel√ºlet tolja maga el≈ëtt a forr√°spontot
                        // De csak akkor, ha m√©g nincs √°thatol√°s folyamatban ezen a g√∂mbn√©l
                        if (!userData.hasPenetrated) {
                            // A forr√°spont sebess√©g√©t a tasz√≠t√°s ir√°ny√°ba √°ll√≠tjuk (radi√°lisan kifel√©)
                            // A sebess√©g nagys√°ga = g√∂mbfel√ºlet t√°gul√°si sebess√©ge (1 fizikai egys√©g)
                            this.physics_velocity = radialOutward.clone().multiplyScalar(sphereExpansionSpeed);
                            console.log('LOW RELATIVE SPEED: Surface pushes source outward');
                        } else {
                            // √Åthatol√°s m√°r folyamatban volt - hagyjuk folytatni
                            console.log('LOW RELATIVE SPEED: Penetration in progress - continue');
                        }
                    } else {
                        // NAGY relat√≠v sebess√©g (>1): √ÅTHATOL√ÅS sebess√©gcs√∂kken√©ssel
                        // A forr√°spont √°thatol a fel√ºleten, de a sebess√©ge 1-gyel cs√∂kken
                        if (!userData.hasReducedSpeed) {
                            const oldSpeed = this.physics_velocity.length();
                            
                            // A sebess√©g 1 fizikai egys√©ggel cs√∂kken a MOZG√ÅS ir√°ny√°ban
                            const moveDirection = this.physics_velocity.clone().normalize();
                            this.physics_velocity.sub(moveDirection.multiplyScalar(PHYSICS_UNIT_SPEED));
                            
                            const newSpeed = this.physics_velocity.length();
                            console.log(`HIGH RELATIVE SPEED: Penetration - speed reduced from ${(oldSpeed/PHYSICS_UNIT_SPEED).toFixed(2)} to ${(newSpeed/PHYSICS_UNIT_SPEED).toFixed(2)}`);
                            
                            // Jel√∂lj√ºk, hogy ez a g√∂mb m√°r okozott sebess√©gcs√∂kken√©st
                            userData.hasReducedSpeed = true;
                            userData.hasPenetrated = true;
                            userData.hasLeftSource = true;
                            userData.canPushSource = true;
                        } else {
                            console.log('HIGH RELATIVE SPEED: Already reduced for this sphere');
                        }
                    }
                }
            }
        }
    }
}
        // V√°ltoz√≥k
        let scene, camera, renderer;
        let emitterPoint;
        let emitterPoint2 = null; // m√°sodik forr√°spont dual m√≥dban
        let spheres = [];
        let emitters = []; // Emitter objektumok t√∂mbje
        let secondaryEmitter = null; // M√°sodik emitter a dual m√≥dhoz
        
        // 3x3-as t√©rr√°cs v√°ltoz√≥k
        let grid3x3Points = []; // A 27 pont mesh objektumai
        let grid3x3Selected = []; // Kiv√°lasztott pontok koordin√°t√°i
        let grid3x3Mode = false; // Kiv√°laszt√°si m√≥d akt√≠v-e
        let grid3x3Started = false; // A szimul√°ci√≥ elindult-e
        let grid3x3Emitters = []; // A t√©rr√°cs forr√°spontjai (emitterek)
        
        let mouse = { x: 0, y: 0 };
        let isLeftMouseDown = false;
        let isRightMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let cameraDistance = 5;
        let cameraAngleX = 0;
        let cameraAngleY = 0;
        let cameraCenter = { x: 0, y: 0, z: 0 }; // Kamera k√∂z√©ppontja
        let keysPressed = {};
        let isPaused = false;
        let pauseStartTime = 0; // Mikor kezd≈ëd√∂tt a pause
        let totalPausedTime = 0; // √ñsszesen mennyi ideig volt pause √°llapotban
        let speedMultiplier = 1.0; // Sebess√©g szorz√≥ - 1.0 = eredeti sebess√©g, 0.5 = fele sebess√©g, stb.
        
        // Id≈ësz√°l megjelen√≠t√©s v√°ltoz√≥i
        let showTimeline = false; // Id≈ësz√°l megjelen√≠t√©se be/ki
        let timelinePoints = []; // Id≈ësz√°l pontok t√°rol√°sa
        let timelineMarkers = []; // Id≈ësz√°l jel√∂l≈ëk (s√°rga g√∂mb√∂k)
        let timelineLines = []; // Id≈ësz√°l vonalak
        
        // Id≈ësz√°l l√°that√≥s√°g friss√≠t√©se
        function updateTimelineVisibility() {
            // Friss√≠tj√ºk az id≈ësz√°l elemek l√°that√≥s√°g√°t a showTimeline √°llapota alapj√°n
            timelineMarkers.forEach(marker => {
                if (showTimeline && !marker.parent) {
                    scene.add(marker);
                } else if (!showTimeline && marker.parent) {
                    scene.remove(marker);
                }
            });
            
            timelineLines.forEach(line => {
                if (showTimeline && !line.parent) {
                    scene.add(line);
                } else if (!showTimeline && line.parent) {
                    scene.remove(line);
                }
            });
        }
        
        // Az id≈ësz√°l v√°ltoz√≥k m√°r deklar√°lva vannak kor√°bban, itt nem kell √∫jra deklar√°lni ≈ëket
        
        // Kamera k√∂vet√©s √©s forg√°s v√°ltoz√≥k
        let isCameraRotating = false;
        let isFollowingSource = false;
        let followMode = 0; // 0: nincs k√∂vet√©s, 1: I. m√≥d, 2: II. m√≥d
        let cameraRotationSpeed = 0.005; // Kamera forg√°si sebess√©ge
        
        // X √©s Y tengely k√∂r√ºli forgat√°s v√°ltoz√≥k
        let isRotatingAroundX = false; // X tengely k√∂r√ºli forgat√°s
        let isRotatingAroundY = false; // Y tengely k√∂r√ºli forgat√°s
        let sceneRotationSpeed = 0.02; // Sz√≠nt√©r forgat√°si sebess√©ge
        
        // Be√°ll√≠t√°sok
        let emissionIntensity = 0.1;
        let sphereOpacity = 0.5; // Alap√©rtelmezett 0.5 √°tl√°tsz√≥s√°g
        let sourceSpeedX = 1.75; // Forr√°spont sebess√©ge X-ir√°nyban (kezdeti √©rt√©k)
        let sourceSpeedY = 0; // Forr√°spont sebess√©ge Y-ir√°nyban
        let lastEmissionTime = 0;
        const PHYSICS_UNIT_SPEED = 0.002; // A g√∂mb t√°gul√°si sebess√©ge, mint fizikai egys√©g (1 egys√©g)
        //const PHYSICS_UNIT_SPEED2 = 0.002; // A forr√°spont sebess√©ge, mint fizikai egys√©g (1 egys√©g)
        let movementType = 'water'; // 'water', 'fire', 'circular' vagy 'spiral'
        let emitterVelocity = 0; // Kibocs√°jt√≥ pont sebess√©ge x ir√°nyben
        let emitterDirection = 1; // Mozg√°s ir√°nya (1 vagy -1)
        let circleRadius = 4; // K√∂rmozg√°s sugara (ThreeJS egys√©gben, nem pixelben)
        let circleAngle = 0; // K√∂rmozg√°s sz√∂ge
        let spiralHeight = 0; // Spir√°lis mozg√°s magass√°ga
        
        // WaveEmitter oszt√°ly m√°r glob√°lisan defini√°lva van

        // Sebess√©g szorz√≥k a k√ºl√∂nb√∂z≈ë mozg√°st√≠pusokhoz (ezeket az √©rt√©keket lehet finomhangolni)
        const speedMultipliers = {
            fire:     { x: 0.002, y: 0.002 }, // T≈±zelem: cs√∫szka √©rt√©k 0.1 = g√∂mb n√∂veked√©si sebess√©g (0.002)
            circular: { x: 0.002, y: 0.002 }, // K√∂rmozg√°s: kicsit lassabb szorz√≥
            spiral:   { x: 0.002, y: 0.002 }  // Spir√°l: eredeti √©rt√©kek
        };
        let currentXMultiplier = 0; // Az aktu√°lisan kiv√°lasztott mozg√°st√≠pus X-ir√°ny√∫ szorz√≥ja
        let currentYMultiplier = 0; // Az aktu√°lisan kiv√°lasztott mozg√°st√≠pus Y-ir√°ny√∫ szorz√≥ja

        // Cs√∫szk√°k kezd≈ë√©rt√©kei a k√ºl√∂nb√∂z≈ë mozg√°st√≠pusokhoz (0 √©s 6 k√∂z√∂tt)
        const initialSliderValues = {
            fire:     { x: 1.75, y: 0.0 }, 
            circular: { x: 2.0, y: 0.0 }, 
            spiral:   { x: 2.84, y: 1.8 }
        };
        
        // ========== 3x3-as t√©rr√°cs funkci√≥k ==========
        
        // 3x3-as t√©rr√°cs l√©trehoz√°sa
        function createGrid3x3() {
            const spacing = 2.0; // Pontok k√∂z√∂tti t√°vols√°g (nagyobb √©rt√©k = t√°volabb vannak)
            
            // T√∂r√∂lj√ºk a kor√°bbi pontokat (de ne √°ll√≠tsuk vissza a grid3x3Mode-ot)
            grid3x3Points.forEach(point => {
                scene.remove(point);
                point.geometry.dispose();
                point.material.dispose();
            });
            grid3x3Points = [];
            grid3x3Selected = [];
            grid3x3Started = false;
            
            // Kiv√°laszt√°si f√°zisban az eredeti emitter ne √°rasszon ki
            // Elmozd√≠tjuk az eredeti forr√°spontot messzire, hogy ne zavarja a kiv√°laszt√°st
            emitterPoint.position.set(1000, 1000, 1000);
            emitterPoint.visible = false;
            
            // 27 pont l√©trehoz√°sa (3x3x3)
            for (let x = 0; x < 3; x++) {
                for (let y = 0; y < 3; y++) {
                    for (let z = 0; z < 3; z++) {
                        const geometry = new THREE.SphereGeometry(0.08, 16, 16);
                        const material = new THREE.MeshPhongMaterial({
                            color: 0x444444, // S√∂t√©tsz√ºrke
                            shininess: 60,
                            specular: 0x222222
                        });
                        const point = new THREE.Mesh(geometry, material);
                        
                        // Poz√≠ci√≥ be√°ll√≠t√°sa (k√∂z√©pre igaz√≠tva)
                        point.position.set(
                            (x - 1) * spacing,
                            (y - 1) * spacing,
                            (z - 1) * spacing
                        );
                        
                        // T√°roljuk a pont adatait
                        point.userData = {
                            gridIndex: grid3x3Points.length,
                            isSelected: false,
                            originalColor: 0x444444
                        };
                        
                        scene.add(point);
                        grid3x3Points.push(point);
                    }
                }
            }
            
            // Panel megjelen√≠t√©se
            document.getElementById('grid3x3Panel').style.display = 'block';
            updateSelectedCount();
        }
        
        // 3x3-as t√©rr√°cs t√∂rl√©se
        function clearGrid3x3() {
            grid3x3Points.forEach(point => {
                scene.remove(point);
                point.geometry.dispose();
                point.material.dispose();
            });
            grid3x3Points = [];
            grid3x3Selected = [];
            grid3x3Mode = false;
            grid3x3Started = false;
            
            // Panel elrejt√©se
            document.getElementById('grid3x3Panel').style.display = 'none';
            
            // T√©rr√°cs emitterek t√∂rl√©se
            grid3x3Emitters.forEach(emitter => {
                if (emitter.mesh) {
                    scene.remove(emitter.mesh);
                    emitter.mesh.geometry.dispose();
                    emitter.mesh.material.dispose();
                }
                // Elt√°vol√≠tjuk az emitters t√∂mbb≈ël is
                const index = emitters.indexOf(emitter);
                if (index > -1) {
                    emitters.splice(index, 1);
                }
            });
            grid3x3Emitters = [];
        }
        
        // Kiv√°lasztott pontok sz√°m√°nak friss√≠t√©se
        function updateSelectedCount() {
            const count = grid3x3Selected.length;
            document.getElementById('selectedPointCount').textContent = count;
            
            const startBtn = document.getElementById('grid3x3StartBtn');
            if (count > 0) {
                startBtn.disabled = false;
                startBtn.textContent = `Ind√≠t√°s (${count} forr√°spont)`;
            } else {
                startBtn.disabled = true;
                startBtn.textContent = 'Ind√≠t√°s (v√°lassz legal√°bb 1 pontot)';
            }
        }
        
        // Pont kiv√°laszt√°sa/kiv√°laszt√°s visszavon√°sa
        function toggleGridPoint(point) {
            if (!grid3x3Mode || grid3x3Started) return;
            
            point.userData.isSelected = !point.userData.isSelected;
            
            if (point.userData.isSelected) {
                // S√°rg√°ra v√°lt√°s
                point.material.color.setHex(0xffd700);
                point.material.emissive = new THREE.Color(0x332200);
                grid3x3Selected.push(point.position.clone());
            } else {
                // Vissza s√∂t√©tsz√ºrk√©re
                point.material.color.setHex(0x444444);
                point.material.emissive = new THREE.Color(0x000000);
                // Elt√°vol√≠t√°s a kiv√°lasztottak k√∂z√ºl
                const idx = grid3x3Selected.findIndex(pos => 
                    pos.x === point.position.x && 
                    pos.y === point.position.y && 
                    pos.z === point.position.z
                );
                if (idx > -1) {
                    grid3x3Selected.splice(idx, 1);
                }
            }
            
            updateSelectedCount();
        }
        
        // 3x3-as t√©rr√°cs szimul√°ci√≥ ind√≠t√°sa
        function startGrid3x3Simulation() {
            if (grid3x3Selected.length === 0) return;
            
            grid3x3Started = true;
            
            // Panel elrejt√©se
            document.getElementById('grid3x3Panel').style.display = 'none';
            
            // T√∂r√∂lj√ºk a kiv√°laszt√≥ pontokat
            grid3x3Points.forEach(point => {
                scene.remove(point);
                point.geometry.dispose();
                point.material.dispose();
            });
            grid3x3Points = [];
            
            // Elrejtj√ºk az eredeti forr√°spontot
            emitterPoint.visible = false;
            
            // L√©trehozzuk a forr√°spontokat a kiv√°lasztott poz√≠ci√≥kban
            grid3x3Selected.forEach((pos, index) => {
                const geometry = new THREE.SphereGeometry(0.007, 16, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xff0000, // Piros forr√°spont
                    shininess: 80,
                    specular: 0x444444
                });
                const sourceMesh = new THREE.Mesh(geometry, material);
                sourceMesh.position.copy(pos);
                scene.add(sourceMesh);
                
                // Emitter l√©trehoz√°sa
                const newEmitter = new WaveEmitter(sourceMesh);
                emitters.push(newEmitter);
                grid3x3Emitters.push(newEmitter);
            });
            
            console.log(`Grid 3x3 simulation started with ${grid3x3Selected.length} source points`);
        }
        
        // Raycaster a 3x3-as t√©rr√°cs pontok kattint√°s√°hoz
        const grid3x3Raycaster = new THREE.Raycaster();
        
        // ========== Inicializ√°l√°s ==========
        function init() {
            // Jelenet l√©trehoz√°sa
            scene = new THREE.Scene();
            
            // Kamera be√°ll√≠t√°sa
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();
            
            // Renderer l√©trehoz√°sa
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xcccccc, 1);
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Vil√°g√≠t√°s - Fejlesztett vil√°g√≠t√°si rendszer
            // Ambient f√©ny a teljes jelenet alapvil√°g√≠t√°s√°hoz
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            // F≈ë ir√°ny√≠tott f√©nyforr√°s
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(5, 5, 5);
            mainLight.castShadow = true;
            scene.add(mainLight);
            
            // Kieg√©sz√≠t≈ë f√©nyforr√°sok a jobb 3D hat√°s √©rdek√©ben
            const fillLight1 = new THREE.PointLight(0x9090ff, 0.6);
            fillLight1.position.set(-5, 2, 3);
            scene.add(fillLight1);
            
            const fillLight2 = new THREE.PointLight(0xffa040, 0.5);
            fillLight2.position.set(3, -5, -3);
            scene.add(fillLight2);
            
            
            <!-- A WaveEmitter oszt√°ly m√°r glob√°lisan van defini√°lva, itt nincs r√° sz√ºks√©g. -->

// Kibocs√°jt√≥ pont l√©trehoz√°sa (sokkal kisebb piros g√∂mb) - √°rny√©kolt fel√ºlettel
            const emitterGeometry = new THREE.SphereGeometry(0.009, 16, 16); // 0.05 helyett 0.017 (kb 3x kisebb)
            const emitterMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff0000,
                shininess: 80,
                specular: 0x444444
            });
            emitterPoint = new THREE.Mesh(emitterGeometry, emitterMaterial);
            scene.add(emitterPoint);
    const mainEmitter = new WaveEmitter(emitterPoint);
    emitters.push(mainEmitter);

    // A secondaryEmitter v√°ltoz√≥ glob√°lisan van deklar√°lva

            
            // Esem√©nykezel≈ëk
            setupEventListeners();
            
            // Anim√°ci√≥ ind√≠t√°sa
            animate();

            // Kezdeti X √©s Y szorz√≥k be√°ll√≠t√°sa az alap√©rtelmezett mozg√°st√≠pushoz
            const initialMovementType = movementType; // A glob√°lis movementType v√°ltoz√≥ haszn√°lata itt biztons√°gosabb
            console.log('Initial movement type for multipliers:', initialMovementType);
            if (speedMultipliers[initialMovementType] && typeof speedMultipliers[initialMovementType] === 'object') {
                currentXMultiplier = speedMultipliers[initialMovementType].x || 0;
                currentYMultiplier = speedMultipliers[initialMovementType].y || 0;
            } else { // water vagy nem defini√°lt x/y
                currentXMultiplier = 0;
                currentYMultiplier = 0;
            }
        }
        
        function setupEventListeners() {
            // Eg√©r esem√©nyek
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault()); // Jobb klikk men√º letilt√°sa
            
            // Billenty≈±zet esem√©nyek
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            
            // Ablak √°tm√©retez√©s
            window.addEventListener('resize', onWindowResize);
            
            // Cs√∫szk√°k √©s gombok
            const intensitySlider = document.getElementById('intensity');
            const opacitySlider = document.getElementById('opacity');
            const sourceSpeedXSlider = document.getElementById('sourceSpeedX');
            const sourceSpeedYSlider = document.getElementById('sourceSpeedY');
            const circleRadiusSlider = document.getElementById('circleRadiusSlider');
            const circleRadiusControlGroup = document.getElementById('circleRadiusControlGroup');
            const movementTypeSelect = document.getElementById('movementType');
            const pauseBtn = document.getElementById('pauseBtn');
            const resetBtn = document.getElementById('resetBtn');
            const cameraResetBtn = document.getElementById('cameraResetBtn');
            
            intensitySlider.addEventListener('input', (e) => {
                emissionIntensity = parseFloat(e.target.value);
                document.getElementById('intensityValue').textContent = emissionIntensity.toFixed(1);
            });
            
            opacitySlider.addEventListener('input', (e) => {
                sphereOpacity = parseFloat(e.target.value); // K√∂zvetlen√ºl haszn√°ljuk az √©rt√©ket
                document.getElementById('opacityValue').textContent = sphereOpacity.toFixed(2);
                updateSphereMaterials();
            });
            
            sourceSpeedXSlider.addEventListener('input', (e) => {
                sourceSpeedX = parseFloat(e.target.value);
                document.getElementById('sourceSpeedXValue').textContent = sourceSpeedX.toFixed(2);
                console.log('sourceSpeedX changed to:', sourceSpeedX);
                
                // Ha t≈±zelem m√≥dban vagyunk, akkor a physics_velocity-t is friss√≠tj√ºk
                if (movementType === 'fire' && emitters[0]) {
                    const fireVelocityX = sourceSpeedX * currentXMultiplier * emitterDirection * speedMultiplier;
                    emitters[0].physics_velocity.x = fireVelocityX;
                    console.log('SourceSpeedX slider changed, new physics velocity X:', fireVelocityX);
                }
            });

            sourceSpeedYSlider.addEventListener('input', (e) => {
                sourceSpeedY = parseFloat(e.target.value);
                document.getElementById('sourceSpeedYValue').textContent = sourceSpeedY.toFixed(2);
                console.log('sourceSpeedY changed to:', sourceSpeedY);
                
                // Ha t≈±zelem m√≥dban vagyunk, akkor a physics_velocity-t is friss√≠tj√ºk
                if (movementType === 'fire' && emitters[0]) {
                    const fireVelocityY = sourceSpeedY * currentYMultiplier * speedMultiplier;
                    emitters[0].physics_velocity.y = fireVelocityY;
                    console.log('SourceSpeedY slider changed, new physics velocity Y:', fireVelocityY);
                }
            });

            circleRadiusSlider.addEventListener('input', (e) => {
                circleRadius = parseFloat(e.target.value);
                document.getElementById('circleRadiusValue').textContent = circleRadius.toFixed(1);
                console.log('circleRadius changed to:', circleRadius);
            });
            
            movementTypeSelect.addEventListener('change', (e) => {
                // El≈ësz√∂r t√∂r√∂lj√ºk a jelenetet √©s az id≈ësz√°lat is
                resetScene();
                
                movementType = e.target.value;
                // Vissza√°ll√≠tjuk a kibocs√°jt√≥ pont poz√≠ci√≥j√°t
                emitterPoint.position.set(0, 0, 0);
                // Vissza√°ll√≠tjuk a k√∂rmozg√°s √©s spir√°lis mozg√°s v√°ltoz√≥it
                circleAngle = 0;
                spiralHeight = 0;

                // EL≈êSZ√ñR friss√≠tj√ºk a multiplier √©rt√©keket
                if (speedMultipliers[movementType] && typeof speedMultipliers[movementType] === 'object') {
                    currentXMultiplier = speedMultipliers[movementType].x || 0;
                    currentYMultiplier = speedMultipliers[movementType].y || 0;
                } else { // water vagy nem defini√°lt x/y
                    currentXMultiplier = 0;
                    currentYMultiplier = 0;
                }
                
                // M√ÅSODSZOR ellen≈ërizz√ºk, hogy kell-e alap√©rtelmezett √©rt√©keket be√°ll√≠tani
                // Csak akkor √≠rjuk fel√ºl a cs√∫szk√°kat, ha jelenleg 0-n vannak (√∫j ind√≠t√°s)
                if (initialSliderValues[movementType] && sourceSpeedX === 0 && sourceSpeedY === 0) {
                    const initX = initialSliderValues[movementType].x;
                    const initY = initialSliderValues[movementType].y;
                    
                    sourceSpeedXSlider.value = initX;
                    sourceSpeedX = initX;
                    document.getElementById('sourceSpeedXValue').textContent = initX.toFixed(2);
                    console.log('Set sourceSpeedX to initial (was 0):', initX);

                    sourceSpeedYSlider.value = initY;
                    sourceSpeedY = initY;
                    document.getElementById('sourceSpeedYValue').textContent = initY.toFixed(2);
                    console.log('Set sourceSpeedY to initial (was 0):', initY);
                } else if (!initialSliderValues[movementType] && movementType === 'water') {
                    // Csak v√≠z m√≥dban null√°zzuk
                    sourceSpeedXSlider.value = 0;
                    sourceSpeedX = 0;
                    document.getElementById('sourceSpeedXValue').textContent = '0.000';
                    
                    sourceSpeedYSlider.value = 0;
                    sourceSpeedY = 0;
                    document.getElementById('sourceSpeedYValue').textContent = '0.000';
                    console.log('Water mode: setting speeds to 0.');
                } else {
                    console.log('Keeping existing slider values: X=', sourceSpeedX, 'Y=', sourceSpeedY);
                }
                
                // V√âG√úL √°ll√≠tjuk be a fizikai sebess√©get (most m√°r helyes sourceSpeedX/Y √©rt√©kekkel)
                if (movementType === 'fire' && emitters[0]) {
                    // Egyszer≈± konverzi√≥: a cs√∫szka √©rt√©kek k√∂zvetlen√ºl fizikai sebess√©gg√© v√°lnak
                    const fireVelocityX = sourceSpeedX * currentXMultiplier * emitterDirection * speedMultiplier;
                    const fireVelocityY = sourceSpeedY * currentYMultiplier * speedMultiplier;
                    emitters[0].physics_velocity.set(fireVelocityX, fireVelocityY, 0);
                    console.log('Fire mode physics velocity set to:', fireVelocityX, fireVelocityY);
                } else if (emitters[0]) {
                    // M√°s mozg√°st√≠pusokn√°l null√°zzuk a fizikai sebess√©get
                    emitters[0].physics_velocity.set(0, 0, 0);
                }
                console.log('Movement type changed to:', movementType, 'New Multipliers X:', currentXMultiplier, 'Y:', currentYMultiplier);
                emitterPoint.visible = (movementType !== 'water' && movementType !== 'grid3x3');

// 3x3-as t√©rr√°cs m√≥d kezel√©se
if (movementType === 'grid3x3') {
    // Be√°ll√≠tjuk a m√≥dot EL≈êBB
    grid3x3Mode = true;
    // L√©trehozzuk az √∫j t√©rr√°csot (ez t√∂rli a kor√°bbi pontokat is)
    createGrid3x3();
    // Elrejtj√ºk az eredeti forr√°spontot
    emitterPoint.visible = false;
} else {
    // M√°s m√≥d eset√©n t√∂r√∂lj√ºk a t√©rr√°csot
    if (grid3x3Mode || grid3x3Points.length > 0 || grid3x3Emitters.length > 0) {
        clearGrid3x3();
    }
}

// Dual mode: k√©t forr√°spont l√©trehoz√°sa/elt√°vol√≠t√°sa
if (movementType === 'dual') {
    // Els≈ë forr√°spont balra
    emitterPoint.position.set(-2, 0, 0);
    
    // T√∂r√∂lj√ºk a felesleges id≈ësz√°l‚Äëelemeket az els≈ë forr√°spontn√°l,
    // hogy ne maradjon 0,0,0 pontb√≥l indul√≥ s√°rga vonal
    if (typeof mainEmitter !== 'undefined' && mainEmitter.timeline) {
        // T√°vol√≠tsuk el a kor√°bbi vonalakat √©s jel√∂l≈ëket a jelenetb≈ël
        for (let l of mainEmitter.timeline.lines) scene.remove(l);
        for (let m of mainEmitter.timeline.markers) scene.remove(m);
        // √úr√≠ts√ºk a list√°kat
        mainEmitter.timeline = { points: [], markers: [], lines: [] };
    }
// M√°sodik forr√°spont l√©trehoz√°sa, ha m√©g nincs
    if (!emitterPoint2) {
        const emitterGeometry = new THREE.SphereGeometry(0.007, 16, 16); // Ugyanolyan m√©ret, mint az els≈ë forr√°spontn√°l
        const emitterMaterial = new THREE.MeshPhongMaterial({color: 0xff0000, shininess: 80, specular: 0x444444});
        emitterPoint2 = new THREE.Mesh(emitterGeometry, emitterMaterial);
        emitterPoint2.position.set(2, 0, 0);
        scene.add(emitterPoint2);
        
        // M√°sodik emitter l√©trehoz√°sa
        if (!secondaryEmitter) {
            secondaryEmitter = new WaveEmitter(emitterPoint2);
            emitters.push(secondaryEmitter);
        }
    }
} else {
    // M√°s m√≥d eset√©n t√°vol√≠tsuk el a m√°sodik forr√°spontot
    if (emitterPoint2) {
        scene.remove(emitterPoint2);
        emitterPoint2.geometry.dispose();
        emitterPoint2.material.dispose();
        emitterPoint2 = null;
        
        // M√°sodik emitter elt√°vol√≠t√°sa
        if (secondaryEmitter) {
            const index = emitters.indexOf(secondaryEmitter);
            if (index > -1) {
                emitters.splice(index, 1);
            }
            secondaryEmitter = null;
        }
    }
}


                // K√∂rmozg√°s sugara cs√∫szka l√°that√≥s√°g√°nak be√°ll√≠t√°sa
                if (movementType === 'circular' || movementType === 'spiral') {
                    circleRadiusControlGroup.style.display = 'block';
                } else {
                    circleRadiusControlGroup.style.display = 'none';
                }

                // A cs√∫szk√°k be√°ll√≠t√°sa m√°r megt√∂rt√©nt fentebb, a fizikai sebess√©g be√°ll√≠t√°sa el≈ëtt
            });
            
            pauseBtn.addEventListener('click', () => {
                isPaused = !isPaused;
                pauseBtn.textContent = isPaused ? 'Folytat' : 'Sz√ºnet';
                
                if (isPaused) {
                    // Pause kezdete - t√°roljuk az id≈ëpontot
                    pauseStartTime = performance.now();
                } else {
                    // Pause v√©ge - hozz√°adjuk a pause id≈ëtartam√°t az √∂sszeshez
                    totalPausedTime += performance.now() - pauseStartTime;
                }
            });
            
            resetBtn.addEventListener('click', () => {
                resetScene();
            });
            
            cameraResetBtn.addEventListener('click', () => {
                resetCamera();
            });
            
            // 3x3-as t√©rr√°cs Ind√≠t√°s gomb esem√©nykezel≈ëje
            document.getElementById('grid3x3StartBtn').addEventListener('click', () => {
                startGrid3x3Simulation();
            });
            
            // √öj kamera n√©zet gombok esem√©nykezel≈ëi
            document.getElementById('topViewBtn').addEventListener('click', () => {
                setTopView();
                // Kikapcsoljuk a forg√°st √©s k√∂vet√©st
                isCameraRotating = false;
                isFollowingSource = false;
                document.getElementById('rotateViewBtn').classList.remove('active');
                document.getElementById('followSourceBtn1').classList.remove('active');
                document.getElementById('followSourceBtn2').classList.remove('active');
            });
            
            document.getElementById('bottomViewBtn').addEventListener('click', () => {
                setBottomView();
                // Kikapcsoljuk a forg√°st √©s k√∂vet√©st
                isCameraRotating = false;
                isFollowingSource = false;
                document.getElementById('rotateViewBtn').classList.remove('active');
                document.getElementById('followSourceBtn1').classList.remove('active');
                document.getElementById('followSourceBtn2').classList.remove('active');
            });
            
            document.getElementById('rightViewBtn').addEventListener('click', () => {
                setRightView();
                // Kikapcsoljuk a forg√°st √©s k√∂vet√©st
                isCameraRotating = false;
                isFollowingSource = false;
                document.getElementById('rotateViewBtn').classList.remove('active');
                document.getElementById('followSourceBtn1').classList.remove('active');
                document.getElementById('followSourceBtn2').classList.remove('active');
            });
            
            document.getElementById('leftViewBtn').addEventListener('click', () => {
                setLeftView();
                // Kikapcsoljuk a forg√°st √©s k√∂vet√©st
                isCameraRotating = false;
                isFollowingSource = false;
                document.getElementById('rotateViewBtn').classList.remove('active');
                document.getElementById('followSourceBtn1').classList.remove('active');
                document.getElementById('followSourceBtn2').classList.remove('active');
            });
            
            document.getElementById('rotateViewBtn').addEventListener('click', () => {
                toggleCameraRotation();
            });
            
            document.getElementById('followSourceBtn1').addEventListener('click', () => {
                toggleSourceFollowingMode1();
            });
            
            document.getElementById('followSourceBtn2').addEventListener('click', () => {
                toggleSourceFollowingMode2();
            });
            
            // √öjrat√∂lt√©s gomb esem√©nykezel≈ëje
            document.getElementById('reloadBtn').addEventListener('click', () => {
                // Ez a be√°ll√≠t√°s a sessionStorage-ban t√°rol√≥dik, amit az oldal bet√∂lt√©sekor olvasunk ki
                sessionStorage.setItem('resetToWater', 'true');
                
                // Minden be√°ll√≠t√°s vissza√°ll√≠t√°sa alap√©rt√©kekre
                resetAllSettings();
                
                // Az oldal √∫jrat√∂lt√©se, ami minden v√°ltoz√≥t alap√°llapotba √°ll√≠t
                location.reload();
            });
            
            // Minden be√°ll√≠t√°s vissza√°ll√≠t√°sa alap√©rt√©kekre
            function resetAllSettings() {
                // Cs√∫szk√°k vissza√°ll√≠t√°sa alap√©rt√©kekre
                intensitySlider.value = 1.0;
                emissionIntensity = 1.0;
                document.getElementById('intensityValue').textContent = '1.0';
                
                opacitySlider.value = 0.0;
                sphereOpacity = 0.0;
                document.getElementById('opacityValue').textContent = '0.00';
                
                sourceSpeedXSlider.value = 0.0;
                sourceSpeedX = 0.0;
                document.getElementById('sourceSpeedXValue').textContent = '0.000';
                
                sourceSpeedYSlider.value = 0.0;
                sourceSpeedY = 0.0;
                document.getElementById('sourceSpeedYValue').textContent = '0.000';
                
                circleRadiusSlider.value = 2.0;
                circleRadius = 2.0;
                document.getElementById('circleRadiusValue').textContent = '2.0';
                
                // Jel√∂l≈ën√©gyzetek vissza√°ll√≠t√°sa
                document.getElementById('showTimelineCheck').checked = false;
                showTimeline = false;
                
                // Mozg√°st√≠pus vissza√°ll√≠t√°sa 'water'-re
                document.getElementById('movementType').value = 'water';
                movementType = 'water';
                
                // Kamera be√°ll√≠t√°sok vissza√°ll√≠t√°sa
                isCameraRotating = false;
                isFollowingSource = false;
                document.getElementById('rotateViewBtn').classList.remove('active');
                document.getElementById('followSourceBtn1').classList.remove('active');
                document.getElementById('followSourceBtn2').classList.remove('active');
                
                // Sz√ºnet √°llapot vissza√°ll√≠t√°sa
                isPaused = false;
                pauseBtn.textContent = 'Sz√ºnet';
                
                // Id≈ësz√°l t√∂rl√©se
                clearTimeline();
                
                // Jelenet vissza√°ll√≠t√°sa
                resetScene();
            }
            
            // Id≈ësz√°l megjelen√≠t√©s jel√∂l≈ën√©gyzet esem√©nykezel≈ë
            document.getElementById('showTimelineCheck').addEventListener('change', function() {
                showTimeline = this.checked;
                
                // Friss√≠tj√ºk az id≈ësz√°l elemek l√°that√≥s√°g√°t a jel√∂l≈ën√©gyzet √°llapota alapj√°n
                updateTimelineVisibility();
            });
        }
        
        function onMouseDown(event) {
            if (event.button === 0) { // Bal eg√©rgomb
                // 3x3-as t√©rr√°cs m√≥d eset√©n
                if (grid3x3Mode) {
                    // Ha m√©g a kiv√°laszt√°si f√°zisban vagyunk, ellen≈ërizz√ºk a pontokat
                    if (!grid3x3Started && grid3x3Points.length > 0) {
                        const mouseVector = new THREE.Vector2(
                            (event.clientX / window.innerWidth) * 2 - 1,
                            -(event.clientY / window.innerHeight) * 2 + 1
                        );
                        
                        grid3x3Raycaster.setFromCamera(mouseVector, camera);
                        const intersects = grid3x3Raycaster.intersectObjects(grid3x3Points);
                        
                        if (intersects.length > 0) {
                            toggleGridPoint(intersects[0].object);
                        }
                    }
                    // Grid3x3 m√≥dban soha ne mozgassuk a forr√°spontot bal eg√©rgombbal
                    return;
                }
                
                isLeftMouseDown = true;
                updateMousePosition(event);
            } else if (event.button === 2) { // Jobb eg√©rgomb
                isRightMouseDown = true;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        }
        
        function onMouseMove(event) {
            if (isLeftMouseDown) {
                updateMousePosition(event);
            } else if (isRightMouseDown) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;
                
                cameraAngleY += deltaX * 0.01;
                cameraAngleX += deltaY * 0.01;
                
                // F√ºgg≈ëleges sz√∂g korl√°toz√°sa
                cameraAngleX = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraAngleX));
                
                updateCameraPosition();
                
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        }
        
        function onMouseUp(event) {
            if (event.button === 0) {
                isLeftMouseDown = false;
            } else if (event.button === 2) {
                isRightMouseDown = false;
            }
        }
        
        function onKeyDown(event) {
            keysPressed[event.code] = true;
            
            // X √©s Y billenty≈±k kezel√©se a sz√≠nt√©r forgat√°s√°hoz
            if (event.code === 'KeyX') {
                isRotatingAroundX = true;
            }
            if (event.code === 'KeyZ') {
                isRotatingAroundY = true;
            }
            
            // Magyar billenty≈±k kezel√©se a kamera forgat√°s√°hoz
            if (event.key === '≈ë') {
                keysPressed['HungarianO'] = true; // ≈ë billenty≈± - balra forg√°s
            }
            if (event.key === '√∫') {
                keysPressed['HungarianU'] = true; // √∫ billenty≈± - jobbra forg√°s
            }
            if (event.key === '√°') {
                keysPressed['HungarianA'] = true; // √° billenty≈± - felfele forg√°s
            }
            if (event.key === '≈±') {
                keysPressed['HungarianUU'] = true; // ≈± billenty≈± - lefele forg√°s
            }
            
            // P billenty≈± kezel√©se a sz√ºnet/folytat√°s funkci√≥hoz
            if (event.code === 'KeyP') {
                // Csak a billenty≈± lenyom√°sakor v√°ltson, ne folyamatosan
                if (!event.repeat) {
                    // Ugyanazt csin√°ljuk, mint a sz√ºnet gomb kattint√°sakor
                    isPaused = !isPaused;
                    document.getElementById('pauseBtn').textContent = isPaused ? 'Folytat' : 'Sz√ºnet';
                    
                    if (isPaused) {
                        // Pause kezdete - t√°roljuk az id≈ëpontot
                        pauseStartTime = performance.now();
                    } else {
                        // Pause v√©ge - hozz√°adjuk a pause id≈ëtartam√°t az √∂sszeshez
                        totalPausedTime += performance.now() - pauseStartTime;
                    }
                }
            }
            
            // O billenty≈± kezel√©se a sebess√©g szab√°lyoz√°s√°hoz
            if (event.code === 'KeyO') {
                // Csak a billenty≈± lenyom√°sakor v√°ltson, ne folyamatosan
                if (!event.repeat) {
                    // Sebess√©g v√°lt√°s: 1.0 -> 0.5 -> 0.25 -> 0.125 -> 1.0 (k√∂rforg√°s)
                    if (speedMultiplier === 1.0) {
                        speedMultiplier = 0.5; // Fele sebess√©g
                    } else if (speedMultiplier === 0.5) {
                        speedMultiplier = 0.25; // Negyed sebess√©g
                    } else if (speedMultiplier === 0.25) {
                        speedMultiplier = 0.125; // Nyolcad sebess√©g
                    } else {
                        speedMultiplier = 1.0; // Vissza az eredeti sebess√©gre
                    }
                    console.log('Sebess√©g m√≥dos√≠tva:', speedMultiplier);
                }
            }
        }
        
        function onKeyUp(event) {
            keysPressed[event.code] = false;
            
            // X √©s Y billenty≈±k felenged√©s√©nek kezel√©se
            if (event.code === 'KeyX') {
                isRotatingAroundX = false;
            }
            if (event.code === 'KeyZ') {
                isRotatingAroundY = false;
            }
            
            // Magyar billenty≈±k felenged√©s√©nek kezel√©se
            if (event.key === '≈ë') {
                keysPressed['HungarianO'] = false; // ≈ë billenty≈± - balra forg√°s
            }
            if (event.key === '√∫') {
                keysPressed['HungarianU'] = false; // √∫ billenty≈± - jobbra forg√°s
            }
            if (event.key === '√°') {
                keysPressed['HungarianA'] = false; // √° billenty≈± - felfele forg√°s
            }
            if (event.key === '≈±') {
                keysPressed['HungarianUU'] = false; // ≈± billenty≈± - lefele forg√°s
            }
        }
        
        

function handleKeyboardMovement() {
    const moveSpeed = 0.1;

    // Aktu√°lis ir√°nyvektorok a kamera koordin√°t√°i szerint
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward).normalize();          // N√©zeti ir√°ny
    const right = new THREE.Vector3();
    right.crossVectors(forward, camera.up).normalize();     // Jobb ir√°ny (k√©perny≈ë jobbra)
    const upDir = new THREE.Vector3();
    upDir.crossVectors(right, forward).normalize();         // K√©perny≈ë felfel√© (kamera‚Äëkoordin√°ta Y)

    /* Bal / Jobb : ArrowLeft / ArrowRight vagy A / D */
    if (keysPressed['ArrowLeft'] || keysPressed['KeyA']) {
        cameraCenter.x -= right.x * moveSpeed;
        cameraCenter.y -= right.y * moveSpeed;
        cameraCenter.z -= right.z * moveSpeed;
    }
    if (keysPressed['ArrowRight'] || keysPressed['KeyD']) {
        cameraCenter.x += right.x * moveSpeed;
        cameraCenter.y += right.y * moveSpeed;
        cameraCenter.z += right.z * moveSpeed;
    }

    /* Fel / Le : ArrowUp / ArrowDown ‚Äì a kamera aktu√°lis ‚Äûfelfel√©‚Äù ir√°ny√°ban */
    if (keysPressed['ArrowUp']) {
        cameraCenter.x += upDir.x * moveSpeed;
        cameraCenter.y += upDir.y * moveSpeed;
        cameraCenter.z += upDir.z * moveSpeed;
    }
    if (keysPressed['ArrowDown']) {
        cameraCenter.x -= upDir.x * moveSpeed;
        cameraCenter.y -= upDir.y * moveSpeed;
        cameraCenter.z -= upDir.z * moveSpeed;
    }

    /* El≈ëre / H√°tra : W / S billenty≈± */
    if (keysPressed['KeyW']) {
        cameraCenter.x += forward.x * moveSpeed;
        cameraCenter.y += forward.y * moveSpeed;
        cameraCenter.z += forward.z * moveSpeed;
    }
    if (keysPressed['KeyS']) {
        cameraCenter.x -= forward.x * moveSpeed;
        cameraCenter.y -= forward.y * moveSpeed;
        cameraCenter.z -= forward.z * moveSpeed;
    }

    updateCameraPosition();
}


        
        function onMouseWheel(event) {
            event.preventDefault();
            cameraDistance += event.deltaY * 0.01;
            cameraDistance = Math.max(1, Math.min(20, cameraDistance)); // Korl√°toz√°s 1-20 k√∂z√∂tt
            updateCameraPosition();
        }
        
        function updateCameraPosition() {
            const x = cameraDistance * Math.sin(cameraAngleY) * Math.cos(cameraAngleX);
            const y = cameraDistance * Math.sin(cameraAngleX);
            const z = cameraDistance * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
            
            camera.position.set(
                x + cameraCenter.x, 
                y + cameraCenter.y, 
                z + cameraCenter.z
            );
            camera.lookAt(cameraCenter.x, cameraCenter.y, cameraCenter.z);
        }
        
        function resetCamera() {
            cameraDistance = 5;
            cameraAngleX = 0;
            cameraAngleY = 0;
            cameraCenter = { x: 0, y: 0, z: 0 };
            isCameraRotating = false;
            isFollowingSource = false;
            updateCameraPosition();
        }
        
        function setTopView() {
            // Fel√ºln√©zet: X tengely k√∂r√ºli -90 fokos elford√≠t√°s (fel√ºlr≈ël n√©zve)
            cameraAngleX = -Math.PI/2 + 0.1; // +0.1 hogy ne legyen teljesen mer≈ëleges
            updateCameraPosition();
        }
        
        function setBottomView() {
            // Aluln√©zet: X tengely k√∂r√ºli +90 fokos elford√≠t√°s (alulr√≥l n√©zve)
            cameraAngleX = Math.PI/2 - 0.1; // -0.1 hogy ne legyen teljesen mer≈ëleges
            updateCameraPosition();
        }
        
        function setRightView() {
            // Jobb oldaln√©zet: Y tengely k√∂r√ºli -90 fokos elford√≠t√°s
            cameraAngleX = 0;
            cameraAngleY = -Math.PI/2;
            updateCameraPosition();
        }
        
        function setLeftView() {
            // Bal oldaln√©zet: Y tengely k√∂r√ºli +90 fokos elford√≠t√°s
            cameraAngleX = 0;
            cameraAngleY = Math.PI/2;
            updateCameraPosition();
        }
        
        function toggleCameraRotation() {
            // Kamera forg√°s be/kikapcsol√°sa
            isCameraRotating = !isCameraRotating;
            
            // Ha bekapcsoljuk a forg√°st, kapcsoljuk ki a forr√°spont k√∂vet√©st
            if (isCameraRotating) {
                isFollowingSource = false;
                followMode = 0;
                document.getElementById('followSourceBtn1').classList.remove('active');
                document.getElementById('followSourceBtn2').classList.remove('active');
                document.getElementById('rotateViewBtn').classList.add('active');
            } else {
                document.getElementById('rotateViewBtn').classList.remove('active');
            }
        }
        
        function toggleSourceFollowingMode1() {
            // Forr√°spont k√∂vet√©s I. m√≥d be/kikapcsol√°sa
            if (followMode === 1) {
                // Ha m√°r I. m√≥dban vagyunk, kikapcsoljuk
                followMode = 0;
                isFollowingSource = false;
                // Vissza√°ll√≠tjuk az eredeti t√°vols√°got
                cameraDistance = 5;
                document.getElementById('followSourceBtn1').classList.remove('active');
            } else {
                // Be√°ll√≠tjuk az I. m√≥dot
                followMode = 1;
                isFollowingSource = true;
                isCameraRotating = false;
                // Norm√°l t√°vols√°g a forr√°spontt√≥l
                cameraDistance = 5;
                // Alaphelyzetbe √°ll√≠tjuk a kamera sz√∂geket
                cameraAngleX = 0;
                cameraAngleY = 0;
                
                // Kikapcsoljuk a m√°sik m√≥dot √©s a forg√°st
                document.getElementById('followSourceBtn2').classList.remove('active');
                document.getElementById('rotateViewBtn').classList.remove('active');
                document.getElementById('followSourceBtn1').classList.add('active');
            }
        }
        
        function toggleSourceFollowingMode2() {
            // Forr√°spont k√∂vet√©s II. m√≥d be/kikapcsol√°sa
            if (followMode === 2) {
                // Ha m√°r II. m√≥dban vagyunk, kikapcsoljuk
                followMode = 0;
                isFollowingSource = false;
                // Vissza√°ll√≠tjuk az eredeti t√°vols√°got
                cameraDistance = 5;
                document.getElementById('followSourceBtn2').classList.remove('active');
            } else {
                // Be√°ll√≠tjuk a II. m√≥dot
                followMode = 2;
                isFollowingSource = true;
                isCameraRotating = false;
                // K√∂zelebbi kamera t√°vols√°g a forr√°sponthoz
                cameraDistance = 2; // Sokkal k√∂zelebb a forr√°sponthoz
                // Enyh√©n fel√ºlr≈ël n√©zz√ºk a forr√°spontot
                cameraAngleX = -0.3;
                
                // Kikapcsoljuk a m√°sik m√≥dot √©s a forg√°st
                document.getElementById('followSourceBtn1').classList.remove('active');
                document.getElementById('rotateViewBtn').classList.remove('active');
                document.getElementById('followSourceBtn2').classList.add('active');
            }
        }
        
        function updateMousePosition(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Kibocs√°jt√≥ pont poz√≠ci√≥j√°nak friss√≠t√©se
            const vector = new THREE.Vector3(mouse.x, mouse.y, 0);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            emitterPoint.position.copy(pos);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function createSphere() {
            // Nagyobb felbont√°s√∫ g√∂mb geometria a jobb megjelen√≠t√©shez
            const geometry = new THREE.SphereGeometry(0.1, 32, 24);
            
            // √Åtl√°tsz√≥ k√©k fel√ºleti anyag - PhongMaterial a f√©nyes fel√ºlet√©rt (mint a piros g√∂mb)
            const baseMaterial = new THREE.MeshPhongMaterial({
                color: 0x6666ff,
                transparent: sphereOpacity > 0, // Csak akkor √°tl√°tsz√≥, ha a cs√∫szka nem 0-n√°l van
                opacity: sphereOpacity === 0 ? 1.0 : 1 - sphereOpacity, // 0-n√°l teljesen √°tl√°tszatlan
                shininess: 80,
                specular: 0x444444,
                side: THREE.DoubleSide,
                visible: sphereOpacity < 1 // Csak akkor l√°that√≥ ha nem teljesen √°tl√°tsz√≥
            });
            
            // Wireframe anyag - mindig l√°that√≥ s√∂t√©tebb sz√ºrke vonalakkal
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0x404040,
                wireframe: true,
                transparent: false,
                opacity: 1.0,
                depthTest: true,
                wireframeLinewidth: 1
            });
            
            // G√∂mb l√©trehoz√°sa a kombin√°lt anyagokkal
            const sphere = new THREE.Group();
            const baseSphereMesh = new THREE.Mesh(geometry, baseMaterial);
            const wireframeSphereMesh = new THREE.Mesh(geometry, wireframeMaterial);
            
            sphere.add(baseSphereMesh);
            sphere.add(wireframeSphereMesh);
            
            // Poz√≠ci√≥ be√°ll√≠t√°sa
            sphere.position.copy(emitterPoint.position);
            
            // Felhaszn√°l√≥i adatok t√°rol√°sa a k√©s≈ëbbi anim√°ci√≥hoz
            sphere.userData = {
                centerPosition: new THREE.Vector3(emitterPoint.position.x, emitterPoint.position.y, emitterPoint.position.z),
                scale: 0.1,
                growthRate: 0.02,
                life: 0,
                baseMaterial: baseMaterial,
                wireframeMaterial: wireframeMaterial,
                baseMesh: baseSphereMesh,
                wireframeMesh: wireframeSphereMesh
            };
            
            // Hozz√°ad√°s a jelenethez √©s a g√∂mb√∂k list√°j√°hoz
            scene.add(sphere);
            spheres.push(sphere);
        }

// --- √öj seg√©df√ºggv√©ny: g√∂mb l√©trehoz√°sa tetsz≈ëleges forr√°sponton ---
function createSphereAt(sourceMesh) {
    const geometry = new THREE.SphereGeometry(0.1, 32, 24);
    const baseMaterial = new THREE.MeshPhongMaterial({
        color: 0x6666ff,
        transparent: sphereOpacity > 0,
        opacity: sphereOpacity === 0 ? 1.0 : 1 - sphereOpacity,
        shininess: 80,
        specular: 0x444444,
        side: THREE.DoubleSide
    });
    const wireframeMaterial = new THREE.MeshBasicMaterial({
        color: 0x404040,
        wireframe: true,
        transparent: false,
        opacity: 1.0,
        depthTest: true
    });
    const sphere = new THREE.Group();
    const solid = new THREE.Mesh(geometry, baseMaterial);
    const wire = new THREE.Mesh(geometry, wireframeMaterial);
    sphere.add(solid);
    sphere.add(wire);
    sphere.position.copy(sourceMesh.position);
    sphere.userData = {
        centerPosition: sourceMesh.position.clone(),
        scale: 0.1,
        growthRate: 0.02,
        life: 0,
        baseMaterial,
        wireframeMaterial,
        baseMesh: solid,
        wireframeMesh: wire
    };
    scene.add(sphere);
    spheres.push(sphere);
}
        
        function updateSphereMaterials() {
            spheres.forEach(sphere => {
                const userData = sphere.userData;
                if (userData.baseMaterial && userData.wireframeMaterial && userData.baseMesh) {
                    // Fokozatos √°tl√°tsz√≥s√°g cs√∂kkent√©se az id≈ë m√∫l√°s√°val
                    const ageFactor = Math.min(userData.life * 0.005, 0.8);
                    
                    // Ha az √°tl√°tsz√≥s√°g 1 (cs√∫szka jobb sz√©l√©n), akkor csak a wireframe l√°tszik
                    if (sphereOpacity === 1) {
                        userData.baseMesh.visible = false;
                        const wireframeOpacity = 1.0 * (1 - ageFactor * 0.01);
                        userData.wireframeMaterial.opacity = Math.max(wireframeOpacity, 0.2);
                    } else {
                        // Ha az √°tl√°tsz√≥s√°g kisebb mint 1, akkor mindk√©t anyag l√°tszik
                        userData.baseMesh.visible = true;
                        
                        // Alap anyag √°tl√°tsz√≥s√°g√°nak friss√≠t√©se - szil√°rd fel√ºlet
                        // Ha a cs√∫szka 0-n√°l van, akkor teljesen √°tl√°tszatlan (opacity = 1.0)
                        // Egy√©bk√©nt az √©letkor alapj√°n cs√∂kken az √°tl√°tszatlans√°g
                        let baseOpacity;
                        if (sphereOpacity === 0) {
                            baseOpacity = 1.0; // Teljesen √°tl√°tszatlan
                        } else {
                            baseOpacity = (1 - sphereOpacity) * (1 - ageFactor);
                        }
                        userData.baseMaterial.opacity = Math.max(baseOpacity, 0.0);
                        userData.baseMaterial.needsUpdate = true;
                        
                        // Wireframe √°tl√°tsz√≥s√°g√°nak friss√≠t√©se
                        const wireframeOpacity = 1.0 * (1 - ageFactor * 0.5);
                        userData.wireframeMaterial.opacity = Math.max(wireframeOpacity, 0.2);
                    }
                    
                    userData.wireframeMaterial.needsUpdate = true;
                }
            });
        }
        
        // Id≈ësz√°l megjelen√≠t√©s f√ºggv√©nyek
        function addTimelinePoint(position) {
            // T√°roljuk a pontot
            timelinePoints.push(position.clone());
            
            // K√©sz√≠ts√ºnk egy s√°rga g√∂mb√∂t jel√∂l≈ënek, ami ugyanolyan m√©ret≈± √©s megjelen√©s≈±, mint a piros forr√°spont
            const markerGeometry = new THREE.SphereGeometry(0.009, 16, 16); // Ugyanolyan m√©ret √©s felbont√°s, mint a forr√°spont
            const markerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffff00, 
                shininess: 80, 
                specular: 0x444444 
            }); // Ugyanolyan anyag, csak s√°rga sz√≠nnel
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.copy(position);
            
            // Csak akkor adjuk hozz√° a jelenethez, ha be van kapcsolva a megjelen√≠t√©s
            if (showTimeline) {
                scene.add(marker);
            }
            
            timelineMarkers.push(marker);
            
            // Ha m√°r van legal√°bb k√©t pont, akkor √∂sszek√∂tj√ºk ≈ëket egy vonallal
            if (timelinePoints.length > 1) {
                const lastIndex = timelinePoints.length - 1;
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    timelinePoints[lastIndex - 1],
                    timelinePoints[lastIndex]
                ]);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                
                // Csak akkor adjuk hozz√° a jelenethez, ha be van kapcsolva a megjelen√≠t√©s
                if (showTimeline) {
                    scene.add(line);
                }
                
                timelineLines.push(line);
            }
        }
        
        function clearTimeline() {
            // Elt√°vol√≠tjuk az √∂sszes jel√∂l≈ët a jelenetb≈ël
            timelineMarkers.forEach(marker => {
                if (marker.parent) {
                    scene.remove(marker);
                }
                if (marker.geometry) marker.geometry.dispose();
                if (marker.material) marker.material.dispose();
            });
            
            // Elt√°vol√≠tjuk az √∂sszes vonalat a jelenetb≈ël
            timelineLines.forEach(line => {
                if (line.parent) {
                    scene.remove(line);
                }
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
            });
            
            // T√∂r√∂lj√ºk a t√°rolt adatokat
            timelinePoints = [];
            timelineMarkers = [];
            timelineLines = [];
        }
        
        function updateTimelineVisibility() {
            // Friss√≠tj√ºk az id≈ësz√°l elemek l√°that√≥s√°g√°t a showTimeline √°llapota alapj√°n
            timelineMarkers.forEach(marker => {
                if (showTimeline && !marker.parent) {
                    scene.add(marker);
                } else if (!showTimeline && marker.parent) {
                    scene.remove(marker);
                }
            });
            
            timelineLines.forEach(line => {
                if (showTimeline && !line.parent) {
                    scene.add(line);
                } else if (!showTimeline && line.parent) {
                    scene.remove(line);
                }
            });
        }
        
        function resetScene() {
            // G√∂mb√∂k elt√°vol√≠t√°sa
            spheres.forEach(sphere => {
                scene.remove(sphere);
                if (sphere.userData.baseMaterial) sphere.userData.baseMaterial.dispose();
                if (sphere.userData.wireframeMaterial) sphere.userData.wireframeMaterial.dispose();
            });
            spheres.length = 0;
            
            // Id≈ësz√°l t√∂rl√©se
            // Elt√°vol√≠tjuk az √∂sszes jel√∂l≈ët a jelenetb≈ël
            timelineMarkers.forEach(marker => {
                if (marker.parent) {
                    scene.remove(marker);
                }
                if (marker.geometry) marker.geometry.dispose();
                if (marker.material) marker.material.dispose();
            });
            
            // Elt√°vol√≠tjuk az √∂sszes vonalat a jelenetb≈ël
            timelineLines.forEach(line => {
                if (line.parent) {
                    scene.remove(line);
                }
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
            });
            
            // T√∂r√∂lj√ºk a t√°rolt adatokat
            timelinePoints = [];
            timelineMarkers = [];
            timelineLines = [];
            
            // Kibocs√°jt√≥ pont vissza√°ll√≠t√°sa k√∂z√©pre
            emitterPoint.position.set(0, 0, 0);
            
            // Emitterek vissza√°ll√≠t√°sa
            emitters.forEach(emitter => {
                emitter.physics_velocity.set(0, 0, 0);

// ---- Id≈ësz√°l ki√ºr√≠t√©se minden emittern√©l ----
if (emitter.timeline) {
    // T√°vol√≠tsuk el a vonalakat √©s jel√∂l≈ëket a jelenetb≈ël
    emitter.timeline.lines.forEach(l => {
        if (l.parent) scene.remove(l);
        if (l.geometry) l.geometry.dispose();
        if (l.material) l.material.dispose();
    });
    emitter.timeline.markers.forEach(m => {
        if (m.parent) scene.remove(m);
        if (m.geometry) m.geometry.dispose();
        if (m.material) m.material.dispose();
    });
    // √úr√≠ts√ºk a list√°kat
    emitter.timeline = { points: [], markers: [], lines: [] };
}
                emitter.resync();
            });
            
            // Biztos√≠tjuk, hogy a forr√°spont l√°that√≥ legyen
            if (emitterPoint) {
                emitterPoint.visible = true;
                // Friss√≠tj√ºk a forr√°spont anyag√°t, hogy biztosan l√°that√≥ legyen
                if (emitterPoint.material) {
                    emitterPoint.material.opacity = 1.0;
                    emitterPoint.material.transparent = false;
                    emitterPoint.material.needsUpdate = true;
                }
            }
            
            // Id≈ëz√≠t≈ëk vissza√°ll√≠t√°sa
            lastEmissionTime = 0;
            totalPausedTime = 0; // Pause id≈ëz√≠t≈ë vissza√°ll√≠t√°sa
            pauseStartTime = 0;
            
            // K√∂rmozg√°s √©s spir√°lis mozg√°s v√°ltoz√≥k vissza√°ll√≠t√°sa
            circleAngle = 0;
            spiralHeight = 0;
            
            // 3x3-as t√©rr√°cs vissza√°ll√≠t√°sa
            if (grid3x3Mode || grid3x3Points.length > 0 || grid3x3Emitters.length > 0) {
                clearGrid3x3();
            }
        }
        
        function animate(time) {
            const pos_before_frame = (emitters.length > 0 && emitters[0]) ? emitters[0].mesh.position.clone() : null;
            requestAnimationFrame(animate);
            
            // Billenty≈±zetes kamera mozgat√°s kezel√©se
            handleKeyboardMovement();
            
            // Magyar billenty≈±k kezel√©se a kamera forgat√°s√°hoz
            const rotationSpeed = 0.05;
            
            // ≈ë - balra forg√°s
            if (keysPressed['HungarianO']) {
                cameraAngleY -= rotationSpeed;
                updateCameraPosition();
            }
            
            // √∫ - jobbra forg√°s
            if (keysPressed['HungarianU']) {
                cameraAngleY += rotationSpeed;
                updateCameraPosition();
            }
            
            // √° - felfele forg√°s - EGYSZER≈∞S√çTETT MEGOLD√ÅS
            if (keysPressed['HungarianA']) {
                // Csak a f√ºgg≈ëleges sz√∂get m√≥dos√≠tjuk
                const tempY = cameraAngleY; // Elmentj√ºk az Y sz√∂get
                cameraAngleX -= rotationSpeed;
                // F√ºgg≈ëleges sz√∂g korl√°toz√°sa
                cameraAngleX = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraAngleX));
                
                // Manu√°lisan sz√°m√≠tjuk ki a kamera poz√≠ci√≥j√°t
                const x = cameraDistance * Math.sin(tempY) * Math.cos(cameraAngleX);
                const y = cameraDistance * Math.sin(cameraAngleX);
                const z = cameraDistance * Math.cos(tempY) * Math.cos(cameraAngleX);
                
                camera.position.set(
                    x + cameraCenter.x, 
                    y + cameraCenter.y, 
                    z + cameraCenter.z
                );
                camera.lookAt(cameraCenter.x, cameraCenter.y, cameraCenter.z);
                
                // Vissza√°ll√≠tjuk az eredeti Y sz√∂get
                cameraAngleY = tempY;
            }
            
            // ≈± - lefele forg√°s - EGYSZER≈∞S√çTETT MEGOLD√ÅS
            if (keysPressed['HungarianUU']) {
                // Csak a f√ºgg≈ëleges sz√∂get m√≥dos√≠tjuk
                const tempY = cameraAngleY; // Elmentj√ºk az Y sz√∂get
                cameraAngleX += rotationSpeed;
                // F√ºgg≈ëleges sz√∂g korl√°toz√°sa
                cameraAngleX = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraAngleX));
                
                // Manu√°lisan sz√°m√≠tjuk ki a kamera poz√≠ci√≥j√°t
                const x = cameraDistance * Math.sin(tempY) * Math.cos(cameraAngleX);
                const y = cameraDistance * Math.sin(cameraAngleX);
                const z = cameraDistance * Math.cos(tempY) * Math.cos(cameraAngleX);
                
                camera.position.set(
                    x + cameraCenter.x, 
                    y + cameraCenter.y, 
                    z + cameraCenter.z
                );
                camera.lookAt(cameraCenter.x, cameraCenter.y, cameraCenter.z);
                
                // Vissza√°ll√≠tjuk az eredeti Y sz√∂get
                cameraAngleY = tempY;
            }
            
            // Kamera forg√°s kezel√©se
            if (isCameraRotating) {
                cameraAngleY += cameraRotationSpeed;
                updateCameraPosition();
            }
            
            // X √©s Y tengely k√∂r√ºli forgat√°s kezel√©se
            if (isRotatingAroundX) {
                // X tengely k√∂r√ºli forgat√°s - a teljes sz√≠nteret forgatjuk
                scene.rotation.x += sceneRotationSpeed;
            }
            
            if (isRotatingAroundY) {
                // Y tengely k√∂r√ºli forgat√°s - a teljes sz√≠nteret forgatjuk
                scene.rotation.y += sceneRotationSpeed;
            }
            
            // Forr√°spont k√∂vet√©s kezel√©se
            if (isFollowingSource && !isPaused) {
                // A kamera k√∂z√©ppontj√°t a forr√°spontra √°ll√≠tjuk
                cameraCenter.x = emitterPoint.position.x;
                cameraCenter.y = emitterPoint.position.y;
                cameraCenter.z = emitterPoint.position.z;
                
                // II. m√≥d: K√∂zeli k√∂vet√©s, mozg√°sir√°ny-alapu kamera
                if (followMode === 2 && movementType !== 'water') {
                    // Mozg√°s ir√°ny√°nak meghat√°roz√°sa
                    if (movementType === 'fire') {
                        // T≈±zelem eset√©n a mozg√°s ir√°nya alapj√°n √°ll√≠tjuk be a kamera sz√∂g√©t
                        cameraAngleY = (sourceSpeedX > 0) ? Math.PI : 0; // Ha jobbra mozog, balr√≥l n√©zz√ºk, ha balra, akkor jobbr√≥l
                    } else if (movementType === 'circular' || movementType === 'spiral') {
                        // K√∂rmozg√°s eset√©n a k√∂r√∂n bel√ºlr≈ël n√©zz√ºk
                        // A k√∂rmozg√°s sz√∂g√©vel ellent√©tes ir√°nyba n√©z a kamera
                        cameraAngleY = circleAngle + Math.PI;
                    }
                }
                
                // I. m√≥d: Egyszer≈± k√∂vet√©s, fix kamera sz√∂gekkel
                // Ebben a m√≥dban nem v√°ltoztatjuk a kamera sz√∂geket, csak a k√∂z√©ppontot k√∂vetj√ºk
                
                updateCameraPosition();
            }
            
            // Kibocs√°jt√≥ pont mozgat√°sa a kiv√°lasztott mozg√°st√≠pus szerint
            if (!isPaused) {
                if (movementType === 'fire') {
                    // T≈±zelem eset√©n a mozg√°st teljes m√©rt√©kben a fizikai modellre b√≠zzuk
                    // A felhaszn√°l√≥i sebess√©gbe√°ll√≠t√°st √°tvisz√ºk a physics_velocity-be
                    emitters.forEach(emitter => {
                        // Csak akkor √°ll√≠tjuk be a kezdeti sebess√©get, ha m√©g nincs jelent≈ës mozg√°s
                        // Ez lehet≈ëv√© teszi, hogy a sebess√©gcs√∂kkent√©s megmaradjon
                        const currentSpeed = emitter.physics_velocity.length();
                        
                        // Csak akkor √°ll√≠tjuk be √∫jra, ha a jelenlegi sebess√©g nagyon kicsi (< 0.001)
                        if (currentSpeed < PHYSICS_UNIT_SPEED * 0.5) {
                            emitter.physics_velocity.set(
                                sourceSpeedX * PHYSICS_UNIT_SPEED,
                                sourceSpeedY * PHYSICS_UNIT_SPEED,
                                0
                            );
                            console.log(`Fire mode physics velocity set to: ${emitter.physics_velocity.x} ${emitter.physics_velocity.y}`);
                        }
                    });
                }
                else if (movementType === 'circular') {
                    const angular_displacement = sourceSpeedX * currentXMultiplier * speedMultiplier;
                    const prev_angle = circleAngle;
                    circleAngle += angular_displacement;

                    const prev_x = Math.cos(prev_angle) * circleRadius;
                    const prev_z = Math.sin(prev_angle) * circleRadius;

                    const new_x = Math.cos(circleAngle) * circleRadius;
                    const new_z = Math.sin(circleAngle) * circleRadius;

                    const displacement = new THREE.Vector3(
                        new_x - prev_x,
                        sourceSpeedY * currentYMultiplier * speedMultiplier, // A f√ºgg≈ëleges mozg√°s egyszer≈± sebess√©g
                        new_z - prev_z
                    );
                    
                    // A poz√≠ci√≥t a kisz√°molt elmozdul√°ssal friss√≠tj√ºk, ahelyett hogy fel√ºl√≠rn√°nk.
                    emitterPoint.position.add(displacement);
                }
                else if (movementType === 'spiral') {
                    const angular_displacement = sourceSpeedX * currentXMultiplier * 0.5 * speedMultiplier;
                    const prev_angle = circleAngle;
                    circleAngle += angular_displacement;

                    const prev_x = Math.cos(prev_angle) * circleRadius;
                    const prev_z = Math.sin(prev_angle) * circleRadius;

                    const new_x = Math.cos(circleAngle) * circleRadius;
                    const new_z = Math.sin(circleAngle) * circleRadius;

                    const y_displacement = sourceSpeedY * currentYMultiplier * speedMultiplier;
                    
                    const displacement = new THREE.Vector3(
                        new_x - prev_x,
                        y_displacement,
                        new_z - prev_z
                    );

                    // A poz√≠ci√≥t itt is addit√≠v m√≥don friss√≠tj√ºk.
                    emitterPoint.position.add(displacement);
                    spiralHeight += y_displacement; // A magass√°got tov√°bbra is k√∂vetj√ºk, de a poz√≠ci√≥t nem √≠rja fel√ºl.
                }
            }
            
            // Ha nincs pause √°llapotban √©s nem vagyunk grid3x3 kiv√°laszt√°si f√°zisban
            if (!isPaused && !(grid3x3Mode && !grid3x3Started)) {
                // Korrig√°lt id≈ë: a pause alatt eltelt id≈ët levonjuk
                const currentTime = performance.now() - totalPausedTime;
                
                // Emitterek friss√≠t√©se (g√∂mb kibocs√°jt√°s)
                emitters.forEach(emitter => {
                    emitter.update(currentTime);
                });
                
                // Fizikai modell friss√≠t√©se: sebess√©g alkalmaz√°sa √©s √∫j er≈ëk sz√°m√≠t√°sa
                emitters.forEach(emitter => {
                    // El≈ësz√∂r alkalmazzuk az el≈ëz≈ë frame-ben sz√°m√≠tott fizikai sebess√©get a poz√≠ci√≥ra
                    emitter.mesh.position.add(emitter.physics_velocity);

                    // Majd az √∫j poz√≠ci√≥ alapj√°n kisz√°m√≠tjuk a k√∂vetkez≈ë frame-re hat√≥ er≈ëket (√ºtk√∂z√©seket)
                    emitter.updateCollisionPhysics();
                });
                
                // G√∂mb√∂k friss√≠t√©se
                updateSpheres();
            }
            // Forr√°spont sebess√©g√©nek kijelz√©se a teljes, t√©nyleges elmozdul√°s alapj√°n
            if (pos_before_frame) {
                const pos_after_frame = emitters[0].mesh.position;
                const total_velocity_this_frame = new THREE.Vector3().subVectors(pos_after_frame, pos_before_frame);
                const speed = total_velocity_this_frame.length();
                
                // A sebess√©get a fizikai egys√©ghez (g√∂mb t√°gul√°si sebess√©ge) viszony√≠tjuk
                const displaySpeed = speed / PHYSICS_UNIT_SPEED;
                const velocityElement = document.getElementById('velocity-value');
                if (velocityElement) {
                    velocityElement.textContent = displaySpeed.toFixed(3);
                }
            }
            
            // Renderel√©s mindig fut (hogy az eg√©r mozgat√°s l√°that√≥ legyen pause alatt is)
            renderer.render(scene, camera);
        }
        
        // Kezdeti inicializ√°l√°s - csak egyszer h√≠vjuk meg
        init();
        
        // Oldal friss√≠t√©sekor alap√°llapotba √°ll√≠t√°s
        // A window.onbeforeunload esem√©ny nem megfelel≈ë erre a c√©lra, mert az oldal bez√°r√°sakor is lefut
        
        // Oldalpanel ki-be g√∂rget√©s gomb esem√©nykezel≈ëje
        const sidePanelToggle = document.getElementById('sidePanelToggle');
        const controlsPanel = document.getElementById('controls');
        
        // Toggle funkci√≥ az oldalpanelhez
        function toggleSidePanel() {
            const isCollapsed = controlsPanel.classList.toggle('collapsed');
            sidePanelToggle.classList.toggle('collapsed', isCollapsed);
            
            // Panel √°llapot√°nak ment√©se
            sessionStorage.setItem('controlsPanelCollapsed', isCollapsed ? 'true' : 'false');
        }
        
        sidePanelToggle.addEventListener('click', toggleSidePanel);
        
        // Panel √°llapot√°nak bet√∂lt√©se az el≈ëz≈ë √°llapotb√≥l
        if (sessionStorage.getItem('controlsPanelCollapsed') === 'true') {
            controlsPanel.classList.add('collapsed');
            sidePanelToggle.classList.add('collapsed');
        }
        
        // Inform√°ci√≥s panel (instructions) ki-be g√∂rget√©s gomb esem√©nykezel≈ëje
        const instructionsPanelToggle = document.getElementById('instructionsPanelToggle');
        const instructionsPanel = document.getElementById('instructions');
        
        // Toggle funkci√≥ az inform√°ci√≥s panelhez
        function toggleInstructionsPanel() {
            const isCollapsed = instructionsPanel.classList.toggle('collapsed');
            instructionsPanelToggle.classList.toggle('collapsed', isCollapsed);
            
            // Panel √°llapot√°nak ment√©se
            sessionStorage.setItem('instructionsPanelCollapsed', isCollapsed ? 'true' : 'false');
        }
        
        instructionsPanelToggle.addEventListener('click', toggleInstructionsPanel);
        
        // Inform√°ci√≥s panel: indul√°skor nyitva, majd 3 m√°sodperc ut√°n automatikusan becsuk√≥dik
        // Ez csak az els≈ë megnyit√°skor t√∂rt√©nik meg (sessionStorage-ban t√°roljuk, hogy m√°r volt-e automatikus bez√°r√°s)
        if (!sessionStorage.getItem('instructionsAutoCloseDone')) {
            // Els≈ë megnyit√°s - panel nyitva marad, majd 3 mp ut√°n becsuk√≥dik
            setTimeout(() => {
                instructionsPanel.classList.add('collapsed');
                instructionsPanelToggle.classList.add('collapsed');
                sessionStorage.setItem('instructionsPanelCollapsed', 'true');
                sessionStorage.setItem('instructionsAutoCloseDone', 'true');
            }, 1000);
        } else if (sessionStorage.getItem('instructionsPanelCollapsed') === 'true') {
            // K√©s≈ëbbi megnyit√°sok - az el≈ëz≈ë √°llapot vissza√°ll√≠t√°sa
            instructionsPanel.classList.add('collapsed');
            instructionsPanelToggle.classList.add('collapsed');
        }
        
        // Ellen≈ërizz√ºk, hogy √∫jrat√∂lt√©s t√∂rt√©nt-e, √©s ha igen, √°ll√≠tsuk a mozg√°st√≠pust V√≠zelemre
        if (sessionStorage.getItem('resetToWater') === 'true') {
            // T√∂r√∂lj√ºk a jelz≈ët
            sessionStorage.removeItem('resetToWater');
            
            // Be√°ll√≠tjuk a mozg√°st√≠pust V√≠zelemre
            const movementTypeSelect = document.getElementById('movementType');
            movementTypeSelect.value = 'water';
            
            // Aktiv√°ljuk a v√°ltoz√°s esem√©nyt, hogy a k√≥d minden sz√ºks√©ges v√°ltoz√≥t friss√≠tsen
            const event = new Event('change');
            movementTypeSelect.dispatchEvent(event);
            
            // Megh√≠vjuk a resetScene() f√ºggv√©nyt is, hogy minden v√°ltoz√≥t alaphelyzetbe √°ll√≠tson
            resetScene();
            
            console.log('Mozg√°st√≠pus V√≠zelemre √°ll√≠tva √©s jelenet vissza√°ll√≠tva az √∫jrat√∂lt√©s ut√°n.');
        }
    
// ====== SPHERE UPDATE LOGIC (2025-05-28) ======
function updateSpheres() {
    for (let i = 0; i < spheres.length; i++) {
        const sphere = spheres[i];
        const userData = sphere.userData;
        
        // A poz√≠ci√≥ a r√∂gz√≠tett k√∂z√©pponton marad
        sphere.position.copy(userData.centerPosition);
        
        // Folyamatos m√©ret n√∂vel√©se - konstans alapsebess√©g
        userData.scale += userData.growthRate;
        sphere.scale.set(userData.scale, userData.scale, userData.scale);
        
        // √âlettartam n√∂vel√©se
        userData.life++;
        
        // Ellen≈ërizz√ºk, hogy a g√∂mb kapcsolatban van-e a saj√°t forr√°spontj√°val
        if (userData.emitter) {
            const sourcePosition = userData.emitter.mesh.position;
            const sphereCenter = userData.centerPosition;
            const sourceRadius = 0.007; // A forr√°spont sugara
            const sphereRadius = userData.scale * 0.1; // A g√∂mb jelenlegi sugara
            
            // T√°vols√°g a forr√°spont √©s a g√∂mb k√∂z√∂tt
            const distance = sphereCenter.distanceTo(sourcePosition);
            
            // Ha a g√∂mb nem √©rintkezik a forr√°sponttal (forr√°spont k√≠v√ºl van)
            if (distance > sphereRadius + sourceRadius) {
                userData.hasLeftSource = true;
                // FONTOS: Ha a forr√°spont k√≠v√ºlre ker√ºlt, resetelj√ºk MINDK√âT flag-et
                // Ez lehet≈ëv√© teszi, hogy ha √∫jra bel√©p a g√∂mbbe, √∫jra m≈±k√∂dj√∂n az √ºtk√∂z√©sdetekt√°l√°s
                // √©s a sebess√©gcs√∂kkent√©s is √∫jra megt√∂rt√©njen
                userData.hasPenetrated = false;
                userData.hasReducedSpeed = false;
            }
            
            // Ha m√°r elhagyta a forr√°spontot, akkor enged√©lyezz√ºk, hogy tasz√≠tsa azt
            if (userData.hasLeftSource) {
                userData.canPushSource = true;
            }
        }
        
        // G√∂mb√∂k elt√°vol√≠t√°sa ha t√∫l nagyok
        if (userData.scale > 400) {
            scene.remove(sphere);
            if (userData.baseMaterial) userData.baseMaterial.dispose();
            if (userData.wireframeMaterial) userData.wireframeMaterial.dispose();
            spheres.splice(i, 1);
            i--; // Kompenz√°ljuk a t√∂mbindexet
        }
    }
    
    // Max 200 g√∂mb megtart√°sa - a legr√©gebbiek t√∂rl√©se, ha t√∫ll√©pn√©nk a hat√°rt
    if (spheres.length > 400) {
        // Rendezz√ºk a g√∂mb√∂ket √©letkor szerint, a legr√©gebbieket el√∂re
        spheres.sort((a, b) => a.userData.life - b.userData.life);
        
        // T√∂r√∂lj√ºk a legr√©gebbi g√∂mb√∂ket, am√≠g a sz√°m vissza nem cs√∂kken 200-ra
        while (spheres.length > 400) {
            const oldestSphere = spheres.shift(); // Elt√°vol√≠tjuk a legr√©gebbit
            
            // Ha van emitter, akkor elt√°vol√≠tjuk a g√∂mb√∂t az emitter list√°j√°b√≥l is
            if (oldestSphere.userData.emitter) {
                const emitter = oldestSphere.userData.emitter;
                const index = emitter.spheres.indexOf(oldestSphere);
                if (index !== -1) {
                    emitter.spheres.splice(index, 1);
                }
            }
            
            // Elt√°vol√≠tjuk a g√∂mb√∂t a jelenetb≈ël √©s felszabad√≠tjuk a forr√°sait
            scene.remove(oldestSphere);
            if (oldestSphere.userData.baseMaterial) oldestSphere.userData.baseMaterial.dispose();
            if (oldestSphere.userData.wireframeMaterial) oldestSphere.userData.wireframeMaterial.dispose();
        }
    }
    
    // Friss√≠tj√ºk az √∂sszes g√∂mb √°tl√°tsz√≥s√°g√°t
    updateSphereMaterials();
}

// ====== MODIFIED TRANSPARENCY LOGIC (2025-05-25) ======
function updateSphereMaterials() {
    spheres.forEach(sphere => {
        const userData = sphere.userData;
        if (userData.baseMaterial && userData.wireframeMaterial && userData.baseMesh) {
            // Linear mapping: slider 0 -> fully opaque, 1 -> fully transparent base (wireframe only)
            const baseOpacity = 1 - sphereOpacity;

            // Solid surface visibility & properties
            userData.baseMesh.visible = baseOpacity > 0.02;      // hide when virtually transparent
            userData.baseMaterial.opacity = baseOpacity;
            userData.baseMaterial.transparent = sphereOpacity > 0;
            userData.baseMaterial.needsUpdate = true;

            // Wireframe is always visible, with gentle opacity
            userData.wireframeMaterial.opacity = 0.9;
            userData.wireframeMaterial.needsUpdate = true;
        }
    });
}

// New createSphere that keeps transparency constant while sphere grows
function createSphere() {
    // High‚Äëresolution geometry for smoother shading
    const geometry = new THREE.SphereGeometry(0.1, 32, 24);

    // Base (solid) material
    const baseMaterial = new THREE.MeshPhongMaterial({
        color: 0x6666ff,
        transparent: sphereOpacity > 0,
        opacity: 1 - sphereOpacity,      // linear mapping
        shininess: 80,
        specular: 0x444444,
        side: THREE.DoubleSide
    });

    // Wireframe overlay
    const wireframeMaterial = new THREE.MeshBasicMaterial({
        color: 0x404040,
        wireframe: true,
        transparent: false,
        opacity: 1.0,
        depthTest: true
    });

    // Assemble sphere
    const sphere = new THREE.Group();
    const baseSphereMesh = new THREE.Mesh(geometry, baseMaterial);
    const wireframeSphereMesh = new THREE.Mesh(geometry, wireframeMaterial);
    sphere.add(baseSphereMesh);
    sphere.add(wireframeSphereMesh);

    // Initial position at emitter
    sphere.position.copy(emitterPoint.position);

    // Metadata for animation (note: opacity no longer varies with life)
    sphere.userData = {
        centerPosition: emitterPoint.position.clone(),
        scale: 0.1,
        growthRate: 0.02,
        life: 0,
        baseMaterial,
        wireframeMaterial,
        baseMesh: baseSphereMesh,
        wireframeMesh: wireframeSphereMesh
    };

    scene.add(sphere);
    spheres.push(sphere);
}
// ====== END OF MODIFICATIONS ======


// ====== CLIPPING PLANES AND EXTR√ÅK PANEL (2025-05-25) ======
// Clipping plane variables
let clipXActive = false;
let clipYActive = false;
const planeX = new THREE.Plane(new THREE.Vector3(1, 0, 0), 0);  // Keep negative X side
const planeY = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);  // Keep negative Y side

function updateClipping() {
    const planes = [];
    if (clipXActive) planes.push(planeX);
    if (clipYActive) planes.push(planeY);
    renderer.clippingPlanes = planes;
    renderer.localClippingEnabled = planes.length > 0;
}

// Note: Extras panel is now integrated into the side panel, no separate collapse handler needed



// ====== Updated clipping buttons with sliders (2025‚Äë05‚Äë25) ======
const clipXSlider = document.getElementById('clipXSlider');
const clipYSlider = document.getElementById('clipYSlider');
const clipXSliderGroup = document.getElementById('clipXSliderGroup');
const clipYSliderGroup = document.getElementById('clipYSliderGroup');

// Swap button functionality
clipXBtn.addEventListener('click', () => {
    clipYActive = !clipYActive;                       // toggle Y-plane
    clipXBtn.classList.toggle('active', clipYActive);
    if (clipYActive) {
        clipXSliderGroup.style.display = 'block';
    } else {
        clipXSliderGroup.style.display = 'none';
        clipXSlider.value = 0;
        clipXSliderValue.textContent = '0.0';
        planeY.constant = 0;
    }
    updateClipping();
});

clipYBtn.addEventListener('click', () => {
    clipXActive = !clipXActive;                       // toggle X-plane
    clipYBtn.classList.toggle('active', clipXActive);
    if (clipXActive) {
        clipYSliderGroup.style.display = 'block';
    } else {
        clipYSliderGroup.style.display = 'none';
        clipYSlider.value = 0;
        clipYSliderValue.textContent = '0.0';
        planeX.constant = 0;
    }
    updateClipping();
});

// Slider movement
clipXSlider.addEventListener('input', () => {
    const val = parseFloat(clipXSlider.value);
    planeY.constant = -val;
    clipXSliderValue.textContent = val.toFixed(1);
    updateClipping();
});
clipYSlider.addEventListener('input', () => {
    const val = parseFloat(clipYSlider.value);
    planeX.constant = -val;
    clipYSliderValue.textContent = val.toFixed(1);
    updateClipping();
});

// Initial arrow state
if (extrasPanel.classList.contains('collapsed')) {
    toggleExtrasBtn.textContent = '';
        toggleExtrasBtn.textContent = '‚ñº';
    toggleExtrasBtn.title = 'Panel kinyit√°sa';
} else {
    toggleExtrasBtn.textContent = '';
        toggleExtrasBtn.textContent = '‚ñ≤';
    toggleExtrasBtn.title = 'Panel √∂sszez√°r√°sa';
}

</script>

<!-- Screen recorder functionality -->
<script src="screen_recorder.js"></script>
</body>
</html>