<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <title>Hull√°mt√©r Szimul√°tor</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #fff;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 24px;
            left: 24px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(15, 23, 42, 1) 0%, rgba(30, 41, 59, 1) 100%);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            padding: 24px;
            border-radius: 16px;
            color: #f8fafc;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            width: 460px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
        }
        
        #controls.collapsed {
            height: 70px;
            min-width: 460px;
            width: 460px;
            padding: 16px 24px;
        }
        
        #controls.collapsed > *:not(.panel-header) {
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
        }
        
        #controls.collapsed .panel-header {
            margin-bottom: 0;
        }
        
        #controls.collapsed #toggleControlsBtn {
            transform: rotate(180deg);
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 28px;
            position: relative;
        }

        .panel-title {
            font-weight: 600;
            font-size: 18px;
            color: #f1f5f9;
            letter-spacing: -0.025em;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .panel-title::before {
            content: '‚ö°';
            font-size: 20px;
            background: linear-gradient(45deg, #3b82f6, #8b5cf6);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #toggleControlsBtn {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 14px 0 rgba(59, 130, 246, 0.3);
        }
        
        #toggleControlsBtn::after {
            content: '‚ñ≤';
            display: block;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #toggleControlsBtn:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
            transform: translateY(-1px);
            box-shadow: 0 8px 25px 0 rgba(59, 130, 246, 0.4);
        }
        
        .control-group {
            margin-bottom: 24px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .control-group:hover {
            transform: translateX(2px);
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #cbd5e1;
            letter-spacing: -0.025em;
        }
        
        input[type="range"] {
            width: 240px;
            height: 6px;
            margin-bottom: 0;
            background: linear-gradient(to right, #1e293b 0%, #334155 100%);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            transition: all 0.3s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.6);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }
        
        .value-display {
            font-size: 13px;
            font-weight: 700;
            color: #ecebeb;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(29, 78, 216, 0.1) 100%);
            padding: 6px 12px;
            border-radius: 20px;
            border: 1px solid rgba(59, 130, 246, 0.2);
            font-family: 'Monaco', 'Menlo', monospace;
            min-width: 50px;
            text-align: center;
        }
        
        button {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            margin-right: 12px;
            margin-bottom: 8px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 14px 0 rgba(59, 130, 246, 0.2);
        }
        
        button:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px 0 rgba(59, 130, 246, 0.3);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 4px 14px 0 rgba(59, 130, 246, 0.2);
        }
        
        select {
            background: #1f2937; /* S√∂t√©tsz√ºrke h√°tt√©r */
            color: #f8fafc;
            border: 1px solid rgba(100, 116, 139, 0.3);
            padding: 10px 16px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 500;
            width: 180px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select option {
            background: #1f2937;
            color: #f8fafc;
            padding: 10px;
        }
        
        select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
        
        select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        select:hover {
            border-color: rgba(148, 163, 184, 0.4);
        }
        
        #instructions {
            position: absolute;
            bottom: 24px;
            right: 24px;
            z-index: 100;
            background: linear-gradient(135deg, rgba(15, 23, 42, 1) 0%, rgba(30, 41, 59, 1) 100%);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            padding: 24px;
            border-radius: 16px;
            color: #f8fafc;
            font-size: 14px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
            max-width: 400px;
            line-height: 1.6;
        }
        
        #instructionsCloseBtn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            transition: all 0.3s ease;
        }
        
        #instructionsCloseBtn:hover {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            transform: scale(1.05);
        }
        
        #version {
            position: absolute;
            top: 24px;
            right: 24px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        .version-container {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.9) 0%, rgba(79, 70, 229, 0.9) 100%);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            display: flex;
            align-items: baseline;
            gap: 6px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .version-number {
            font-size: 12px;
            opacity: 0.9;
            margin-left: 8px;
        }

        .github-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: rgba(17, 24, 39, 0.8);
            color: white;
            text-decoration: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .github-link:hover {
            background: rgba(31, 41, 55, 0.9);
            transform: translateY(-1px);
        }

        .github-link i {
            font-size: 14px;
        }
        
        .instructions-section {
            margin-bottom: 20px;
        }
        
        .instructions-title {
            margin: 0 0 12px 0;
            font-weight: 600;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-section {
            color: #60a5fa;
        }
        
        .function-section {
            color: #34d399;
        }
        
        .instruction-item {
            margin-bottom: 8px;
            padding-left: 4px;
            border-left: 2px solid rgba(148, 163, 184, 0.2);
            padding-left: 12px;
        }
        
        .instruction-item strong {
            color: #e2e8f0;
            font-weight: 600;
        }
        
        /* Anim√°ci√≥ a panel elemekhez */
        .control-group {
            opacity: 1;
            transform: translateY(0);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #controls.collapsed .control-group {
            opacity: 0;
            transform: translateY(-10px);
            transition-delay: 0s;
        }
        
        /* Hover effekt a cs√∫szk√°khoz */
        input[type="range"]:hover {
            background: linear-gradient(to right, #334155 0%, #475569 100%);
        }
        
        /* Elv√°laszt√≥ vonal */
        .divider {
            height: 1px;
            background: linear-gradient(to right, rgba(148, 163, 184, 0.1) 0%, rgba(148, 163, 184, 0.3) 50%, rgba(148, 163, 184, 0.1) 100%);
            margin: 16px 0;
            width: 100%;
        }
        
        /* Gombcsoportok */
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 16px;
        }
        
        .button-group button {
            flex: 1;
            min-width: 120px;
            margin-right: 0;
            white-space: nowrap;
            padding: 10px 12px;
            font-size: 13px;
        }
        
        /* Akt√≠v gombok st√≠lusa */
        button.active {
            background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
            box-shadow: 0 4px 14px 0 rgba(59, 130, 246, 0.5);
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="version">
            <div class="version-container">
                <span class="version-title">Hull√°mt√©r Szimul√°tor</span>
                <span class="version-number">v1.21</span>
            </div>
            <a href="https://github.com/TTomas65/3D-Hullamter-Szimulator" target="_blank" class="github-link">
                Forr√°sk√≥d: <i class="fab fa-github"></i> GitHub
            </a>
        </div>
        <div id="controls">
            <div class="panel-header">
                <div class="panel-title">Ir√°ny√≠t√≥ Panel</div>
                <button id="toggleControlsBtn" title="Panel √∂sszez√°r√°sa/kinyit√°sa"></button>
            </div>
            
            <div class="control-group">
                <label for="intensity">Ki√°rad√°si intenzit√°s</label>
                <input type="range" id="intensity" min="0" max="2" step="0.1" value="0.1">
                <div class="value-display" id="intensityValue">0.1</div>
            </div>
            
            <div class="control-group">
                <label for="opacity">√Åtl√°tsz√≥s√°g</label>
                <input type="range" id="opacity" min="0" max="1" step="0.05" value="0.5">
                <div class="value-display" id="opacityValue">0.50</div>
            </div>
            
            <div class="control-group">
                <label for="sourceSpeedX">Forr√°spont sebess√©ge X-tengely</label>
                <input type="range" id="sourceSpeedX" min="0" max="0.5" step="0.001" value="0">
                <div class="value-display" id="sourceSpeedXValue">0.000</div>
            </div>

            <div class="control-group">
                <label for="sourceSpeedY">Forr√°spont sebess√©ge Y-tengely</label>
                <input type="range" id="sourceSpeedY" min="0" max="0.5" step="0.001" value="0">
                <div class="value-display" id="sourceSpeedYValue">0.000</div>
            </div>

            <div class="control-group" id="circleRadiusControlGroup" style="display: none;">
                <label for="circleRadiusSlider">K√∂rmozg√°s sugara</label>
                <input type="range" id="circleRadiusSlider" min="0" max="5" step="0.1" value="4">
                <div class="value-display" id="circleRadiusValue">4.0</div>
            </div>
            
            <div class="control-group">
                <label for="movementType">Mozg√°st√≠pusok</label>
                <select id="movementType">
                    <option value="water">V√≠zelem</option>
                    <option value="fire">T≈±zelem</option>
                    <option value="circular">K√∂rmozg√°s</option>
                    <option value="spiral">Spir√°lis mozg√°s</option>
                </select>
            </div>
            
            <div class="control-group button-group">
                <button id="pauseBtn">Sz√ºnet</button>
                <button id="resetBtn">√öjrakezd</button>
                <button id="reloadBtn">√öjrat√∂lt√©s</button>
            </div>
            
            <div class="divider"></div>
            
            <div class="control-group button-group">
                <button id="cameraResetBtn">Kamera Reset</button>
                <button id="topViewBtn">Fel√ºln√©zet</button>
                <button id="bottomViewBtn">Aluln√©zet</button>
            </div>
            
            <div class="control-group button-group">
                <button id="rightViewBtn">Oldaln√©zet jobb</button>
                <button id="leftViewBtn">Oldaln√©zet bal</button>
                <button id="rotateViewBtn">Forg√°s</button>
            </div>
            
            <div class="control-group button-group">
                <button id="followSourceBtn1">Forr√°spont k√∂vet√©se I.</button>
                <button id="followSourceBtn2">Forr√°spont k√∂vet√©se II.</button>
            </div>
        </div>
        
        <div id="instructions">
            <button id="instructionsCloseBtn">√ó</button>
            
            <div class="instructions-section">
                <h4 class="instructions-title control-section">üñ±Ô∏è Ir√°ny√≠t√°s</h4>
                <div class="instruction-item"><strong>Bal eg√©rgomb:</strong> Ki√°rad√°si pont mozgat√°sa</div>
                <div class="instruction-item"><strong>Jobb eg√©rgomb:</strong> Kamera forgat√°sa</div>
                <div class="instruction-item"><strong>Eg√©rg√∂rg≈ë:</strong> Zoom be/ki</div>
                <div class="instruction-item"><strong>Nyilak/WASD:</strong> Kamera mozgat√°sa</div>
            </div>
            
            <div class="instructions-section">
                <h4 class="instructions-title function-section">‚öôÔ∏è Funkci√≥k</h4>
                <div class="instruction-item"><strong>Intenzit√°s:</strong> Ki√°rad√°si sebess√©g szab√°lyoz√°sa</div>
                <div class="instruction-item"><strong>√Åtl√°tsz√≥s√°g:</strong> G√∂mb√∂k megjelen√≠t√©se (1=dr√≥tv√°z, 0=szil√°rd)</div>
                <div class="instruction-item"><strong>Forr√°spont sebess√©g:</strong> Mozg√°s sebess√©ge X/Y tengely</div>
                <div class="instruction-item"><strong>Mozg√°st√≠pusok:</strong> K√ºl√∂nb√∂z≈ë anim√°ci√≥s m√≥dok</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // V√°ltoz√≥k
        let scene, camera, renderer;
        let emitterPoint;
        let spheres = [];
        let mouse = { x: 0, y: 0 };
        let isLeftMouseDown = false;
        let isRightMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let cameraDistance = 5;
        let cameraAngleX = 0;
        let cameraAngleY = 0;
        let cameraCenter = { x: 0, y: 0, z: 0 }; // Kamera k√∂z√©ppontja
        let keysPressed = {};
        let isPaused = false;
        
        // Kamera k√∂vet√©s √©s forg√°s v√°ltoz√≥k
        let isCameraRotating = false;
        let isFollowingSource = false;
        let followMode = 0; // 0: nincs k√∂vet√©s, 1: I. m√≥d, 2: II. m√≥d
        let cameraRotationSpeed = 0.005; // Kamera forg√°si sebess√©ge
        
        // Be√°ll√≠t√°sok
        let emissionIntensity = 0.1;
        let sphereOpacity = 0.5; // Alap√©rtelmezett 0.5 √°tl√°tsz√≥s√°g
        let sourceSpeedX = 0; // Forr√°spont sebess√©ge X-ir√°nyban
        let sourceSpeedY = 0; // Forr√°spont sebess√©ge Y-ir√°nyban
        let lastEmissionTime = 0;
        let movementType = 'water'; // 'water', 'fire', 'circular' vagy 'spiral'
        let emitterVelocity = 0; // Kibocs√°jt√≥ pont sebess√©ge x ir√°nyben
        let emitterDirection = 1; // Mozg√°s ir√°nya (1 vagy -1)
        let circleRadius = 4; // K√∂rmozg√°s sugara (ThreeJS egys√©gben, nem pixelben)
        let circleAngle = 0; // K√∂rmozg√°s sz√∂ge
        let spiralHeight = 0; // Spir√°lis mozg√°s magass√°ga

        // Sebess√©g szorz√≥k a k√ºl√∂nb√∂z≈ë mozg√°st√≠pusokhoz (ezeket az √©rt√©keket lehet finomhangolni)
        const speedMultipliers = {
            fire:     { x: 0.05, y: 0.05 }, // T≈±zelem: x-sebess√©g szorz√≥, y-sebess√©g szorz√≥
            circular: { x: 0.03, y: 0.03 }, // K√∂rmozg√°s: x->sz√∂gsebess√©g szorz√≥, y->f√ºgg≈ëleges sebess√©g szorz√≥
            spiral:   { x: 0.05, y: 0.05 }  // Spir√°l: x->alapsebess√©g (sz√∂g/sug√°r) szorz√≥, y->emelked√©si sebess√©g szorz√≥
        };
        let currentXMultiplier = 0; // Az aktu√°lisan kiv√°lasztott mozg√°st√≠pus X-ir√°ny√∫ szorz√≥ja
        let currentYMultiplier = 0; // Az aktu√°lisan kiv√°lasztott mozg√°st√≠pus Y-ir√°ny√∫ szorz√≥ja

        // Cs√∫szk√°k kezd≈ë√©rt√©kei a k√ºl√∂nb√∂z≈ë mozg√°st√≠pusokhoz (0 √©s 0.5 k√∂z√∂tt)
        const initialSliderValues = {
            fire:     { x: 0.07, y: 0.0 }, 
            circular: { x: 0.1, y: 0.0 }, 
            spiral:   { x: 0.142, y: 0.09 }
        };
        
        // Inicializ√°l√°s
        function init() {
            // Jelenet l√©trehoz√°sa
            scene = new THREE.Scene();
            
            // Kamera be√°ll√≠t√°sa
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();
            
            // Renderer l√©trehoz√°sa
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xcccccc, 1);
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Vil√°g√≠t√°s - Fejlesztett vil√°g√≠t√°si rendszer
            // Ambient f√©ny a teljes jelenet alapvil√°g√≠t√°s√°hoz
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            // F≈ë ir√°ny√≠tott f√©nyforr√°s
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(5, 5, 5);
            mainLight.castShadow = true;
            scene.add(mainLight);
            
            // Kieg√©sz√≠t≈ë f√©nyforr√°sok a jobb 3D hat√°s √©rdek√©ben
            const fillLight1 = new THREE.PointLight(0x9090ff, 0.6);
            fillLight1.position.set(-5, 2, 3);
            scene.add(fillLight1);
            
            const fillLight2 = new THREE.PointLight(0xffa040, 0.5);
            fillLight2.position.set(3, -5, -3);
            scene.add(fillLight2);
            
            // Kibocs√°jt√≥ pont l√©trehoz√°sa (sokkal kisebb piros g√∂mb) - √°rny√©kolt fel√ºlettel
            const emitterGeometry = new THREE.SphereGeometry(0.017, 16, 16); // 0.05 helyett 0.017 (kb 3x kisebb)
            const emitterMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff0000,
                shininess: 80,
                specular: 0x444444
            });
            emitterPoint = new THREE.Mesh(emitterGeometry, emitterMaterial);
            scene.add(emitterPoint);
            
            // Esem√©nykezel≈ëk
            setupEventListeners();
            
            // Anim√°ci√≥ ind√≠t√°sa
            animate();

            // Kezdeti X √©s Y szorz√≥k be√°ll√≠t√°sa az alap√©rtelmezett mozg√°st√≠pushoz
            const initialMovementType = movementType; // A glob√°lis movementType v√°ltoz√≥ haszn√°lata itt biztons√°gosabb
            console.log('Initial movement type for multipliers:', initialMovementType);
            if (speedMultipliers[initialMovementType] && typeof speedMultipliers[initialMovementType] === 'object') {
                currentXMultiplier = speedMultipliers[initialMovementType].x || 0;
                currentYMultiplier = speedMultipliers[initialMovementType].y || 0;
            } else { // water vagy nem defini√°lt x/y
                currentXMultiplier = 0;
                currentYMultiplier = 0;
            }
        }
        
        function setupEventListeners() {
            // Eg√©r esem√©nyek
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault()); // Jobb klikk men√º letilt√°sa
            
            // Billenty≈±zet esem√©nyek
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            
            // Ablak √°tm√©retez√©s
            window.addEventListener('resize', onWindowResize);
            
            // Cs√∫szk√°k √©s gombok
            const intensitySlider = document.getElementById('intensity');
            const opacitySlider = document.getElementById('opacity');
            const sourceSpeedXSlider = document.getElementById('sourceSpeedX');
            const sourceSpeedYSlider = document.getElementById('sourceSpeedY');
            const circleRadiusSlider = document.getElementById('circleRadiusSlider');
            const circleRadiusControlGroup = document.getElementById('circleRadiusControlGroup');
            const movementTypeSelect = document.getElementById('movementType');
            const pauseBtn = document.getElementById('pauseBtn');
            const resetBtn = document.getElementById('resetBtn');
            const cameraResetBtn = document.getElementById('cameraResetBtn');
            const instructionsCloseBtn = document.getElementById('instructionsCloseBtn');
            
            intensitySlider.addEventListener('input', (e) => {
                emissionIntensity = parseFloat(e.target.value);
                document.getElementById('intensityValue').textContent = emissionIntensity.toFixed(1);
            });
            
            opacitySlider.addEventListener('input', (e) => {
                sphereOpacity = parseFloat(e.target.value); // K√∂zvetlen√ºl haszn√°ljuk az √©rt√©ket
                document.getElementById('opacityValue').textContent = sphereOpacity.toFixed(2);
                updateSphereMaterials();
            });
            
            sourceSpeedXSlider.addEventListener('input', (e) => {
                sourceSpeedX = parseFloat(e.target.value);
                document.getElementById('sourceSpeedXValue').textContent = sourceSpeedX.toFixed(3);
                console.log('sourceSpeedX changed to:', sourceSpeedX);
            });

            sourceSpeedYSlider.addEventListener('input', (e) => {
                sourceSpeedY = parseFloat(e.target.value);
                document.getElementById('sourceSpeedYValue').textContent = sourceSpeedY.toFixed(3);
                console.log('sourceSpeedY changed to:', sourceSpeedY);
            });

            circleRadiusSlider.addEventListener('input', (e) => {
                circleRadius = parseFloat(e.target.value);
                document.getElementById('circleRadiusValue').textContent = circleRadius.toFixed(1);
                console.log('circleRadius changed to:', circleRadius);
            });
            
            movementTypeSelect.addEventListener('change', (e) => {
                // El≈ësz√∂r t√∂r√∂lj√ºk a jelenetet
                resetScene();
                
                movementType = e.target.value;
                // Vissza√°ll√≠tjuk a kibocs√°jt√≥ pont poz√≠ci√≥j√°t
                emitterPoint.position.set(0, 0, 0);
                // Vissza√°ll√≠tjuk a k√∂rmozg√°s √©s spir√°lis mozg√°s v√°ltoz√≥it
                circleAngle = 0;
                spiralHeight = 0;

                // A glob√°lis 'movementType' v√°ltoz√≥t haszn√°ljuk, amit az esem√©nykezel≈ë elej√©n friss√≠t√ºnk
                if (speedMultipliers[movementType] && typeof speedMultipliers[movementType] === 'object') {
                    currentXMultiplier = speedMultipliers[movementType].x || 0;
                    currentYMultiplier = speedMultipliers[movementType].y || 0;
                } else { // water vagy nem defini√°lt x/y
                    currentXMultiplier = 0;
                    currentYMultiplier = 0;
                }
                console.log('Movement type changed to:', movementType, 'New Multipliers X:', currentXMultiplier, 'Y:', currentYMultiplier);
                emitterPoint.visible = (movementType !== 'water');

                // K√∂rmozg√°s sugara cs√∫szka l√°that√≥s√°g√°nak be√°ll√≠t√°sa
                if (movementType === 'circular' || movementType === 'spiral') {
                    circleRadiusControlGroup.style.display = 'block';
                } else {
                    circleRadiusControlGroup.style.display = 'none';
                }

                // Cs√∫szk√°k √©s sourceSpeed √©rt√©kek be√°ll√≠t√°sa az initialSliderValues alapj√°n
                if (initialSliderValues[movementType]) {
                    const initX = initialSliderValues[movementType].x;
                    const initY = initialSliderValues[movementType].y;

                    sourceSpeedXSlider.value = initX;
                    sourceSpeedX = initX;
                    document.getElementById('sourceSpeedXValue').textContent = initX.toFixed(3);
                    console.log('Set sourceSpeedX to initial:', initX);

                    sourceSpeedYSlider.value = initY;
                    sourceSpeedY = initY;
                    document.getElementById('sourceSpeedYValue').textContent = initY.toFixed(3);
                    console.log('Set sourceSpeedY to initial:', initY);
                } else {
                    // Ha nincs defini√°lt kezd≈ë√©rt√©k (pl. 'water'), null√°zzuk a cs√∫szk√°kat √©s sebess√©geket
                    sourceSpeedXSlider.value = 0;
                    sourceSpeedX = 0;
                    document.getElementById('sourceSpeedXValue').textContent = '0.000';
                    
                    sourceSpeedYSlider.value = 0;
                    sourceSpeedY = 0;
                    document.getElementById('sourceSpeedYValue').textContent = '0.000';
                    console.log('No initial slider values for', movementType, 'setting to 0.');
                }
            });
            
            pauseBtn.addEventListener('click', () => {
                isPaused = !isPaused;
                pauseBtn.textContent = isPaused ? 'Folytat' : 'Sz√ºnet';
            });
            
            resetBtn.addEventListener('click', () => {
                resetScene();
            });
            
            cameraResetBtn.addEventListener('click', () => {
                resetCamera();
            });
            
            // √öj kamera n√©zet gombok esem√©nykezel≈ëi
            document.getElementById('topViewBtn').addEventListener('click', () => {
                setTopView();
                // Kikapcsoljuk a forg√°st √©s k√∂vet√©st
                isCameraRotating = false;
                isFollowingSource = false;
                document.getElementById('rotateViewBtn').classList.remove('active');
                document.getElementById('followSourceBtn1').classList.remove('active');
                document.getElementById('followSourceBtn2').classList.remove('active');
            });
            
            document.getElementById('bottomViewBtn').addEventListener('click', () => {
                setBottomView();
                // Kikapcsoljuk a forg√°st √©s k√∂vet√©st
                isCameraRotating = false;
                isFollowingSource = false;
                document.getElementById('rotateViewBtn').classList.remove('active');
                document.getElementById('followSourceBtn1').classList.remove('active');
                document.getElementById('followSourceBtn2').classList.remove('active');
            });
            
            document.getElementById('rightViewBtn').addEventListener('click', () => {
                setRightView();
                // Kikapcsoljuk a forg√°st √©s k√∂vet√©st
                isCameraRotating = false;
                isFollowingSource = false;
                document.getElementById('rotateViewBtn').classList.remove('active');
                document.getElementById('followSourceBtn1').classList.remove('active');
                document.getElementById('followSourceBtn2').classList.remove('active');
            });
            
            document.getElementById('leftViewBtn').addEventListener('click', () => {
                setLeftView();
                // Kikapcsoljuk a forg√°st √©s k√∂vet√©st
                isCameraRotating = false;
                isFollowingSource = false;
                document.getElementById('rotateViewBtn').classList.remove('active');
                document.getElementById('followSourceBtn1').classList.remove('active');
                document.getElementById('followSourceBtn2').classList.remove('active');
            });
            
            document.getElementById('rotateViewBtn').addEventListener('click', () => {
                toggleCameraRotation();
            });
            
            document.getElementById('followSourceBtn1').addEventListener('click', () => {
                toggleSourceFollowingMode1();
            });
            
            document.getElementById('followSourceBtn2').addEventListener('click', () => {
                toggleSourceFollowingMode2();
            });
            
            // √öjrat√∂lt√©s gomb esem√©nykezel≈ëje
            document.getElementById('reloadBtn').addEventListener('click', () => {
                // Ez a be√°ll√≠t√°s a sessionStorage-ban t√°rol√≥dik, amit az oldal bet√∂lt√©sekor olvasunk ki
                sessionStorage.setItem('resetToWater', 'true');
                
                // Az oldal √∫jrat√∂lt√©se, ami minden v√°ltoz√≥t alap√°llapotba √°ll√≠t
                window.location.reload();
            });
            
            instructionsCloseBtn.addEventListener('click', () => {
                document.getElementById('instructions').style.display = 'none';
            });
        }
        
        function onMouseDown(event) {
            if (event.button === 0) { // Bal eg√©rgomb
                isLeftMouseDown = true;
                updateMousePosition(event);
            } else if (event.button === 2) { // Jobb eg√©rgomb
                isRightMouseDown = true;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        }
        
        function onMouseMove(event) {
            if (isLeftMouseDown) {
                updateMousePosition(event);
            } else if (isRightMouseDown) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;
                
                cameraAngleY += deltaX * 0.01;
                cameraAngleX += deltaY * 0.01;
                
                // F√ºgg≈ëleges sz√∂g korl√°toz√°sa
                cameraAngleX = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraAngleX));
                
                updateCameraPosition();
                
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        }
        
        function onMouseUp(event) {
            if (event.button === 0) {
                isLeftMouseDown = false;
            } else if (event.button === 2) {
                isRightMouseDown = false;
            }
        }
        
        function onKeyDown(event) {
            keysPressed[event.code] = true;
        }
        
        function onKeyUp(event) {
            keysPressed[event.code] = false;
        }
        
        function handleKeyboardMovement() {
            const moveSpeed = 0.1;
            
            // Kamera ir√°ny√°nak kisz√°m√≠t√°sa
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            const right = new THREE.Vector3();
            right.crossVectors(forward, camera.up).normalize();
            
            if (keysPressed['ArrowUp'] || keysPressed['KeyW']) {
                // El≈ëre
                cameraCenter.x += forward.x * moveSpeed;
                cameraCenter.y += forward.y * moveSpeed;
                cameraCenter.z += forward.z * moveSpeed;
            }
            if (keysPressed['ArrowDown'] || keysPressed['KeyS']) {
                // H√°tra
                cameraCenter.x -= forward.x * moveSpeed;
                cameraCenter.y -= forward.y * moveSpeed;
                cameraCenter.z -= forward.z * moveSpeed;
            }
            if (keysPressed['ArrowLeft'] || keysPressed['KeyA']) {
                // Balra
                cameraCenter.x -= right.x * moveSpeed;
                cameraCenter.y -= right.y * moveSpeed;
                cameraCenter.z -= right.z * moveSpeed;
            }
            if (keysPressed['ArrowRight'] || keysPressed['KeyD']) {
                // Jobbra
                cameraCenter.x += right.x * moveSpeed;
                cameraCenter.y += right.y * moveSpeed;
                cameraCenter.z += right.z * moveSpeed;
            }
            
            updateCameraPosition();
        }
        
        function onMouseWheel(event) {
            event.preventDefault();
            cameraDistance += event.deltaY * 0.01;
            cameraDistance = Math.max(1, Math.min(20, cameraDistance)); // Korl√°toz√°s 1-20 k√∂z√∂tt
            updateCameraPosition();
        }
        
        function updateCameraPosition() {
            const x = cameraDistance * Math.sin(cameraAngleY) * Math.cos(cameraAngleX);
            const y = cameraDistance * Math.sin(cameraAngleX);
            const z = cameraDistance * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
            
            camera.position.set(
                x + cameraCenter.x, 
                y + cameraCenter.y, 
                z + cameraCenter.z
            );
            camera.lookAt(cameraCenter.x, cameraCenter.y, cameraCenter.z);
        }
        
        function resetCamera() {
            cameraDistance = 5;
            cameraAngleX = 0;
            cameraAngleY = 0;
            cameraCenter = { x: 0, y: 0, z: 0 };
            isCameraRotating = false;
            isFollowingSource = false;
            updateCameraPosition();
        }
        
        function setTopView() {
            // Fel√ºln√©zet: X tengely k√∂r√ºli -90 fokos elford√≠t√°s (fel√ºlr≈ël n√©zve)
            cameraAngleX = -Math.PI/2 + 0.1; // +0.1 hogy ne legyen teljesen mer≈ëleges
            updateCameraPosition();
        }
        
        function setBottomView() {
            // Aluln√©zet: X tengely k√∂r√ºli +90 fokos elford√≠t√°s (alulr√≥l n√©zve)
            cameraAngleX = Math.PI/2 - 0.1; // -0.1 hogy ne legyen teljesen mer≈ëleges
            updateCameraPosition();
        }
        
        function setRightView() {
            // Jobb oldaln√©zet: Y tengely k√∂r√ºli -90 fokos elford√≠t√°s
            cameraAngleX = 0;
            cameraAngleY = -Math.PI/2;
            updateCameraPosition();
        }
        
        function setLeftView() {
            // Bal oldaln√©zet: Y tengely k√∂r√ºli +90 fokos elford√≠t√°s
            cameraAngleX = 0;
            cameraAngleY = Math.PI/2;
            updateCameraPosition();
        }
        
        function toggleCameraRotation() {
            // Kamera forg√°s be/kikapcsol√°sa
            isCameraRotating = !isCameraRotating;
            
            // Ha bekapcsoljuk a forg√°st, kapcsoljuk ki a forr√°spont k√∂vet√©st
            if (isCameraRotating) {
                isFollowingSource = false;
                followMode = 0;
                document.getElementById('followSourceBtn1').classList.remove('active');
                document.getElementById('followSourceBtn2').classList.remove('active');
                document.getElementById('rotateViewBtn').classList.add('active');
            } else {
                document.getElementById('rotateViewBtn').classList.remove('active');
            }
        }
        
        function toggleSourceFollowingMode1() {
            // Forr√°spont k√∂vet√©s I. m√≥d be/kikapcsol√°sa
            if (followMode === 1) {
                // Ha m√°r I. m√≥dban vagyunk, kikapcsoljuk
                followMode = 0;
                isFollowingSource = false;
                // Vissza√°ll√≠tjuk az eredeti t√°vols√°got
                cameraDistance = 5;
                document.getElementById('followSourceBtn1').classList.remove('active');
            } else {
                // Be√°ll√≠tjuk az I. m√≥dot
                followMode = 1;
                isFollowingSource = true;
                isCameraRotating = false;
                // Norm√°l t√°vols√°g a forr√°spontt√≥l
                cameraDistance = 5;
                // Alaphelyzetbe √°ll√≠tjuk a kamera sz√∂geket
                cameraAngleX = 0;
                cameraAngleY = 0;
                
                // Kikapcsoljuk a m√°sik m√≥dot √©s a forg√°st
                document.getElementById('followSourceBtn2').classList.remove('active');
                document.getElementById('rotateViewBtn').classList.remove('active');
                document.getElementById('followSourceBtn1').classList.add('active');
            }
        }
        
        function toggleSourceFollowingMode2() {
            // Forr√°spont k√∂vet√©s II. m√≥d be/kikapcsol√°sa
            if (followMode === 2) {
                // Ha m√°r II. m√≥dban vagyunk, kikapcsoljuk
                followMode = 0;
                isFollowingSource = false;
                // Vissza√°ll√≠tjuk az eredeti t√°vols√°got
                cameraDistance = 5;
                document.getElementById('followSourceBtn2').classList.remove('active');
            } else {
                // Be√°ll√≠tjuk a II. m√≥dot
                followMode = 2;
                isFollowingSource = true;
                isCameraRotating = false;
                // K√∂zelebbi kamera t√°vols√°g a forr√°sponthoz
                cameraDistance = 2; // Sokkal k√∂zelebb a forr√°sponthoz
                // Enyh√©n fel√ºlr≈ël n√©zz√ºk a forr√°spontot
                cameraAngleX = -0.3;
                
                // Kikapcsoljuk a m√°sik m√≥dot √©s a forg√°st
                document.getElementById('followSourceBtn1').classList.remove('active');
                document.getElementById('rotateViewBtn').classList.remove('active');
                document.getElementById('followSourceBtn2').classList.add('active');
            }
        }
        
        function updateMousePosition(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Kibocs√°jt√≥ pont poz√≠ci√≥j√°nak friss√≠t√©se
            const vector = new THREE.Vector3(mouse.x, mouse.y, 0);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            emitterPoint.position.copy(pos);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function createSphere() {
            // Nagyobb felbont√°s√∫ g√∂mb geometria a jobb megjelen√≠t√©shez
            const geometry = new THREE.SphereGeometry(0.1, 32, 24);
            
            // √Åtl√°tsz√≥ k√©k fel√ºleti anyag - PhongMaterial a f√©nyes fel√ºlet√©rt (mint a piros g√∂mb)
            const baseMaterial = new THREE.MeshPhongMaterial({
                color: 0x6666ff,
                transparent: true,
                opacity: 1 - sphereOpacity, // Ford√≠tott logika
                shininess: 80,
                specular: 0x444444,
                side: THREE.DoubleSide,
                visible: sphereOpacity < 1 // Csak akkor l√°that√≥ ha nem teljesen √°tl√°tsz√≥
            });
            
            // Wireframe anyag - mindig l√°that√≥ s√∂t√©tebb sz√ºrke vonalakkal
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0x404040,
                wireframe: true,
                transparent: false,
                opacity: 1.0,
                depthTest: true,
                wireframeLinewidth: 1
            });
            
            // G√∂mb l√©trehoz√°sa a kombin√°lt anyagokkal
            const sphere = new THREE.Group();
            const baseSphereMesh = new THREE.Mesh(geometry, baseMaterial);
            const wireframeSphereMesh = new THREE.Mesh(geometry, wireframeMaterial);
            
            sphere.add(baseSphereMesh);
            sphere.add(wireframeSphereMesh);
            
            // Poz√≠ci√≥ be√°ll√≠t√°sa
            sphere.position.copy(emitterPoint.position);
            
            // Felhaszn√°l√≥i adatok t√°rol√°sa a k√©s≈ëbbi anim√°ci√≥hoz
            sphere.userData = {
                centerPosition: emitterPoint.position.clone(),
                scale: 0.1,
                growthRate: 0.02,
                life: 0,
                baseMaterial: baseSphereMesh.material,
                wireframeMaterial: wireframeSphereMesh.material,
                baseMesh: baseSphereMesh,
                wireframeMesh: wireframeSphereMesh
            };
            
            // Hozz√°ad√°s a jelenethez √©s a g√∂mb√∂k list√°j√°hoz
            scene.add(sphere);
            spheres.push(sphere);
        }
        
        function updateSphereMaterials() {
            spheres.forEach(sphere => {
                const userData = sphere.userData;
                if (userData.baseMaterial && userData.wireframeMaterial && userData.baseMesh) {
                    
                    // Ha az √°tl√°tsz√≥s√°g 1 (cs√∫szka jobb sz√©l√©n), akkor csak a wireframe l√°tszik
                    if (sphereOpacity === 1) {
                        userData.baseMesh.visible = false;
                        userData.wireframeMaterial.opacity = 1.0;
                    } else {
                        // Ha az √°tl√°tsz√≥s√°g kisebb mint 1, akkor mindk√©t anyag l√°tszik
                        userData.baseMesh.visible = true;
                        
                        // Alap anyag √°tl√°tsz√≥s√°g√°nak be√°ll√≠t√°sa az √°tl√°tsz√≥s√°g √©rt√©ke alapj√°n
                        userData.baseMaterial.opacity = sphereOpacity;
                        userData.baseMaterial.needsUpdate = true;
                        
                        // Wireframe √°tl√°tsz√≥s√°g√°nak friss√≠t√©se
                        userData.wireframeMaterial.opacity = 1.0;
                    }
                    
                    userData.wireframeMaterial.needsUpdate = true;
                }
            });
        }
        
        function resetScene() {
            // G√∂mb√∂k elt√°vol√≠t√°sa
            spheres.forEach(sphere => {
                scene.remove(sphere);
                if (sphere.userData.baseMaterial) sphere.userData.baseMaterial.dispose();
                if (sphere.userData.wireframeMaterial) sphere.userData.wireframeMaterial.dispose();
            });
            spheres.length = 0;
            
            // Kibocs√°jt√≥ pont vissza√°ll√≠t√°sa k√∂z√©pre
            emitterPoint.position.set(0, 0, 0);
            
            // Id≈ëz√≠t≈ëk vissza√°ll√≠t√°sa
            lastEmissionTime = 0;
            
            // K√∂rmozg√°s √©s spir√°lis mozg√°s v√°ltoz√≥k vissza√°ll√≠t√°sa
            circleAngle = 0;
            spiralHeight = 0;
            
            // Pause √°llapot vissza√°ll√≠t√°sa
            isPaused = false;
            document.getElementById('pauseBtn').textContent = 'Sz√ºnet';
        }
        
        function updateSpheres() {
            for (let i = 0; i < spheres.length; i++) {
                const sphere = spheres[i];
                const userData = sphere.userData;
                
                // A poz√≠ci√≥ a r√∂gz√≠tett k√∂z√©pponton marad
                sphere.position.copy(userData.centerPosition);
                
                // Folyamatos m√©ret n√∂vel√©se
                userData.scale += userData.growthRate;
                sphere.scale.set(userData.scale, userData.scale, userData.scale);
                
                // √âlettartam n√∂vel√©se
                userData.life++;
                
                // Fokozatos √°tl√°tsz√≥s√°g cs√∂kkent√©se az id≈ë m√∫l√°s√°val
                const ageFactor = Math.min(userData.life * 0.005, 0.8);
                
                // Friss√≠tj√ºk mindk√©t anyagot
                if (userData.baseMaterial && userData.wireframeMaterial && userData.baseMesh) {
                    
                    // Ha az √°tl√°tsz√≥s√°g 1, akkor csak a wireframe l√°tszik
                    if (sphereOpacity === 1) {
                        userData.baseMesh.visible = false;
                        const wireframeOpacity = 1.0 * (1 - ageFactor * 0.5);
                        userData.wireframeMaterial.opacity = Math.max(wireframeOpacity, 0.2);
                    } else {
                        // Ha az √°tl√°tsz√≥s√°g kisebb mint 1, akkor mindk√©t anyag l√°tszik
                        userData.baseMesh.visible = true;
                        
                        // Alap anyag √°tl√°tsz√≥s√°g√°nak friss√≠t√©se - szil√°rd fel√ºlet
                        const baseOpacity = (1 - sphereOpacity) * (1 - ageFactor);
                        userData.baseMaterial.opacity = Math.max(baseOpacity, 0.0);
                        
                        // Wireframe √°tl√°tsz√≥s√°g√°nak friss√≠t√©se
                        const wireframeOpacity = 1.0 * (1 - ageFactor * 0.5);
                        userData.wireframeMaterial.opacity = Math.max(wireframeOpacity, 0.2);
                    }
                }
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Billenty≈±zetes kamera mozgat√°s kezel√©se
            handleKeyboardMovement();
            
            // Kamera forg√°s kezel√©se
            if (isCameraRotating) {
                cameraAngleY += cameraRotationSpeed;
                updateCameraPosition();
            }
            
            // Forr√°spont k√∂vet√©s kezel√©se
            if (isFollowingSource && !isPaused) {
                // A kamera k√∂z√©ppontj√°t a forr√°spontra √°ll√≠tjuk
                cameraCenter.x = emitterPoint.position.x;
                cameraCenter.y = emitterPoint.position.y;
                cameraCenter.z = emitterPoint.position.z;
                
                // II. m√≥d: K√∂zeli k√∂vet√©s, mozg√°sir√°ny-alapu kamera
                if (followMode === 2 && movementType !== 'water') {
                    // Mozg√°s ir√°ny√°nak meghat√°roz√°sa
                    if (movementType === 'fire') {
                        // T≈±zelem eset√©n a mozg√°s ir√°nya alapj√°n √°ll√≠tjuk be a kamera sz√∂g√©t
                        cameraAngleY = (sourceSpeedX > 0) ? Math.PI : 0; // Ha jobbra mozog, balr√≥l n√©zz√ºk, ha balra, akkor jobbr√≥l
                    } else if (movementType === 'circular' || movementType === 'spiral') {
                        // K√∂rmozg√°s eset√©n a k√∂r√∂n bel√ºlr≈ël n√©zz√ºk
                        // A k√∂rmozg√°s sz√∂g√©vel ellent√©tes ir√°nyba n√©z a kamera
                        cameraAngleY = circleAngle + Math.PI;
                    }
                }
                
                // I. m√≥d: Egyszer≈± k√∂vet√©s, fix kamera sz√∂gekkel
                // Ebben a m√≥dban nem v√°ltoztatjuk a kamera sz√∂geket, csak a k√∂z√©ppontot k√∂vetj√ºk
                
                updateCameraPosition();
            }
            
            // Kibocs√°jt√≥ pont mozgat√°sa a kiv√°lasztott mozg√°st√≠pus szerint
            if (!isPaused) {
                if (movementType === 'fire') {
                    // console.log('Animating fire. SpeedX:', sourceSpeedX, 'MultX:', currentXMultiplier, 'SpeedY:', sourceSpeedY, 'MultY:', currentYMultiplier, 'Direction:', emitterDirection);
                    emitterPoint.position.x += sourceSpeedX * currentXMultiplier * emitterDirection;
                    emitterPoint.position.y += sourceSpeedY * currentYMultiplier; // Y mozg√°s hozz√°ad√°sa
                } 
                else if (movementType === 'circular') {
                    circleAngle += sourceSpeedX * currentXMultiplier;
                    const x_pos = Math.cos(circleAngle) * circleRadius;
                    const z_pos = Math.sin(circleAngle) * circleRadius;
                    emitterPoint.position.y += sourceSpeedY * currentYMultiplier; // Y elmozdul√°s hozz√°ad√°sa
                    emitterPoint.position.set(x_pos, emitterPoint.position.y, z_pos);
                }
                else if (movementType === 'spiral') {
                    const baseAngularSpeed = sourceSpeedX * currentXMultiplier;
                    circleAngle += baseAngularSpeed * 0.5; 
                    const x_pos = Math.cos(circleAngle) * circleRadius;
                    const z_pos = Math.sin(circleAngle) * circleRadius;
                    
                    spiralHeight += sourceSpeedY * currentYMultiplier; // Y-slider vez√©rli az emelked√©st
                    emitterPoint.position.set(x_pos, spiralHeight, z_pos);
                }
            }
            
            // Ha nincs pause √°llapotban
            if (!isPaused) {
                const currentTime = Date.now();
                
                // G√∂mb kibocs√°jt√°s - kev√©sb√© s≈±r≈± alap√©rtelmezett √©rt√©kn√©l
                const emissionInterval = 200 / emissionIntensity; // ms (200 helyett 100)
                if (currentTime - lastEmissionTime > emissionInterval) {
                    createSphere();
                    lastEmissionTime = currentTime;
                }
                
                // G√∂mb√∂k friss√≠t√©se
                updateSpheres();
            }
            
            // Renderel√©s mindig fut (hogy az eg√©r mozgat√°s l√°that√≥ legyen pause alatt is)
            renderer.render(scene, camera);
        }
        
        // Kezdeti inicializ√°l√°s - csak egyszer h√≠vjuk meg
        init();
        
        // Oldal friss√≠t√©sekor alap√°llapotba √°ll√≠t√°s
        // A window.onbeforeunload esem√©ny nem megfelel≈ë erre a c√©lra, mert az oldal bez√°r√°sakor is lefut
        
        // Panel √∂sszez√°r√°s/kinyit√°s gomb esem√©nykezel≈ëje
        const toggleControlsBtn = document.getElementById('toggleControlsBtn');
        const controlsPanel = document.getElementById('controls');
        
        toggleControlsBtn.addEventListener('click', function() {
            controlsPanel.classList.toggle('collapsed');
            
            // Gomb szimb√≥lum√°nak v√°ltoztat√°sa az √°llapot alapj√°n
            if (controlsPanel.classList.contains('collapsed')) {
                toggleControlsBtn.textContent = '‚ñº';
                toggleControlsBtn.title = 'Panel kinyit√°sa';
                // Panel √°llapot√°nak ment√©se
                sessionStorage.setItem('controlsPanelCollapsed', 'true');
            } else {
                toggleControlsBtn.textContent = '‚ñ≤';
                toggleControlsBtn.title = 'Panel √∂sszez√°r√°sa';
                // Panel √°llapot√°nak ment√©se
                sessionStorage.setItem('controlsPanelCollapsed', 'false');
            }
        });
        
        // Panel √°llapot√°nak bet√∂lt√©se az el≈ëz≈ë √°llapotb√≥l
        if (sessionStorage.getItem('controlsPanelCollapsed') === 'true') {
            controlsPanel.classList.add('collapsed');
            toggleControlsBtn.textContent = '‚ñº';
            toggleControlsBtn.title = 'Panel kinyit√°sa';
        }
        
        // Ellen≈ërizz√ºk, hogy √∫jrat√∂lt√©s t√∂rt√©nt-e, √©s ha igen, √°ll√≠tsuk a mozg√°st√≠pust V√≠zelemre
        if (sessionStorage.getItem('resetToWater') === 'true') {
            // T√∂r√∂lj√ºk a jelz≈ët
            sessionStorage.removeItem('resetToWater');
            
            // Be√°ll√≠tjuk a mozg√°st√≠pust V√≠zelemre
            const movementTypeSelect = document.getElementById('movementType');
            movementTypeSelect.value = 'water';
            
            // Aktiv√°ljuk a v√°ltoz√°s esem√©nyt, hogy a k√≥d minden sz√ºks√©ges v√°ltoz√≥t friss√≠tsen
            const event = new Event('change');
            movementTypeSelect.dispatchEvent(event);
            
            console.log('Mozg√°st√≠pus V√≠zelemre √°ll√≠tva az √∫jrat√∂lt√©s ut√°n.');
        }
    </script>
</body>
</html>